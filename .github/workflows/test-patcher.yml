name: Test DualAuth Patcher

on:
  push:
    paths:
      - 'patcher/**'
      - '.github/workflows/test-patcher.yml'
      - '.github/scripts/**'
  pull_request:
    paths:
      - 'patcher/**'
      - '.github/scripts/**'
  workflow_dispatch:
    inputs:
      server_jar_url:
        description: 'Server JAR URL'
        default: 'https://download.sanasol.ws/download/HytaleServerOriginal.jar'
        required: false
      assets_url:
        description: 'Assets.zip URL'
        default: 'https://download.sanasol.ws/download/Assets.zip'
        required: false
      skip_boot_test:
        description: 'Skip server boot test'
        type: boolean
        default: false

env:
  SERVER_JAR_URL: ${{ inputs.server_jar_url || 'https://download.sanasol.ws/download/HytaleServerOriginal.jar' }}
  ASSETS_URL: ${{ inputs.assets_url || 'https://download.sanasol.ws/download/Assets.zip' }}
  HYTALE_AUTH_DOMAIN: 'auth.sanasol.ws'
  HYTALE_AUTH_URL: 'https://auth.sanasol.ws'

jobs:
  test-patcher:
    name: Test Patcher Compilation & Patching
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Download ASM Libraries
        working-directory: patcher
        run: |
          mkdir -p lib
          cd lib
          echo "Downloading ASM 9.6 libraries..."
          curl -sfLO https://repo1.maven.org/maven2/org/ow2/asm/asm/9.6/asm-9.6.jar
          curl -sfLO https://repo1.maven.org/maven2/org/ow2/asm/asm-tree/9.6/asm-tree-9.6.jar
          curl -sfLO https://repo1.maven.org/maven2/org/ow2/asm/asm-util/9.6/asm-util-9.6.jar
          ls -la

      - name: Compile Patcher
        working-directory: patcher
        run: |
          echo "Compiling DualAuthPatcher..."
          javac -cp "lib/*" DualAuthPatcher.java
          ls -la *.class

      - name: Download Original Server JAR
        working-directory: patcher
        run: |
          echo "Downloading server JAR from: $SERVER_JAR_URL"
          curl -sfL "$SERVER_JAR_URL" -o HytaleServerOriginal.jar
          ls -lh HytaleServerOriginal.jar

          # Verify it's not already patched
          if unzip -l HytaleServerOriginal.jar | grep -q "DualAuthContext.class"; then
            echo "::warning::Downloaded JAR appears to already be patched"
          fi

      - name: Run Patcher
        working-directory: patcher
        run: |
          echo "Running DualAuthPatcher..."
          java -cp ".:lib/*" DualAuthPatcher HytaleServerOriginal.jar HytaleServerPatched.jar

          echo ""
          echo "=== Verifying Patched JAR ==="

          # Check for injected classes
          echo "Checking for DualAuth classes..."
          DUAL_CLASSES=$(unzip -l HytaleServerPatched.jar | grep -c "DualAuth\|DualJwks\|DualServer" || echo "0")
          echo "DualAuth classes found: $DUAL_CLASSES"

          if [ "$DUAL_CLASSES" -lt 5 ]; then
            echo "::error::Patching failed - expected at least 5 DualAuth classes"
            exit 1
          fi

          # List injected classes
          unzip -l HytaleServerPatched.jar | grep -E "DualAuth|DualJwks|DualServer"

          echo ""
          echo "Patching successful!"

      - name: Upload Patched JAR
        uses: actions/upload-artifact@v4
        with:
          name: patched-server-jar
          path: patcher/HytaleServerPatched.jar
          retention-days: 7

  test-server-boot:
    name: Test Server Boot
    needs: test-patcher
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: ${{ !inputs.skip_boot_test }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Download Patched JAR
        uses: actions/download-artifact@v4
        with:
          name: patched-server-jar
          path: server

      - name: Cache Assets.zip
        id: cache-assets
        uses: actions/cache@v4
        with:
          path: server/Assets.zip
          key: hytale-assets-v1
          restore-keys: |
            hytale-assets-

      - name: Download Assets
        if: steps.cache-assets.outputs.cache-hit != 'true'
        working-directory: server
        run: |
          echo "Downloading Assets.zip (not cached)..."
          curl -sfL "$ASSETS_URL" -o Assets.zip
          ls -lh Assets.zip

      - name: Verify Assets
        working-directory: server
        run: |
          ls -lh Assets.zip
          echo "Assets ready"

      - name: Verify Production Auth Server
        run: |
          echo "Verifying production auth server at $HYTALE_AUTH_URL..."
          curl -sf "$HYTALE_AUTH_URL/.well-known/jwks.json" | head -5
          echo ""
          echo "Production auth server is reachable"

      - name: Test Server Boot
        working-directory: server
        timeout-minutes: 3
        run: |
          echo "Starting Hytale server boot test (no tokens)..."
          echo "Testing for bytecode patching errors (NoSuchFieldError, etc.)"
          echo ""

          java -Xmx2G -jar HytaleServerPatched.jar \
            --assets Assets.zip \
            --bare \
            --disable-sentry \
            2>&1 | tee server.log &

          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"

          # Wait for boot or error (30s timeout)
          TIMEOUT=30
          ELAPSED=0
          SUCCESS=false
          BYTECODE_ERROR=false

          echo "Monitoring server boot (max ${TIMEOUT}s)..."

          while kill -0 $SERVER_PID 2>/dev/null; do
            sleep 2
            ELAPSED=$((ELAPSED + 2))

            # Check for bytecode errors (patcher compatibility issues)
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server.log 2>/dev/null; then
              echo ""
              echo "::error::Bytecode patching error detected!"
              grep -E "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server.log | head -5
              BYTECODE_ERROR=true
              kill $SERVER_PID 2>/dev/null || true
              break
            fi

            # Check for successful boot - match actual log: "Hytale Server Booted!"
            if grep -qi "Server Booted" server.log 2>/dev/null; then
              echo "Server booted successfully!"
              SUCCESS=true
              # Force kill immediately
              kill $SERVER_PID 2>/dev/null || true
              sleep 1
              kill -9 $SERVER_PID 2>/dev/null || true
              break
            fi

            # Progress
            if [ $((ELAPSED % 10)) -eq 0 ]; then
              echo "... waiting ($ELAPSED/${TIMEOUT}s)"
            fi

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "Timeout reached"
              # Check if we got far enough
              if grep -qi "Server Booted" server.log 2>/dev/null; then
                echo "Server booted (detected after timeout)"
                SUCCESS=true
              elif grep -q "Plugin manager started\|Universe ready" server.log 2>/dev/null; then
                echo "Server reached plugin stage - patcher is compatible"
                SUCCESS=true
              fi
              break
            fi
          done

          # Force kill server
          echo "Stopping server..."
          kill $SERVER_PID 2>/dev/null || true
          sleep 1
          kill -9 $SERVER_PID 2>/dev/null || true
          pkill -9 -f HytaleServerPatched.jar 2>/dev/null || true

          echo ""
          echo "=== Server Log (last 20 lines) ==="
          tail -20 server.log

          echo ""
          echo "=== DualAuth Log Messages ==="
          grep -i "DualAuth" server.log | head -10 || echo "No DualAuth messages found"

          echo ""
          echo "=== Test Result ==="
          if [ "$BYTECODE_ERROR" = true ]; then
            echo "FAILED: Bytecode patching error"
            exit 1
          elif [ "$SUCCESS" = true ]; then
            echo "PASSED: Server booted without bytecode errors"
            exit 0
          else
            echo "UNKNOWN: Check logs for details"
            exit 0
          fi

      - name: Upload Server Log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: server-boot-log
          path: server/server.log
          retention-days: 7

  test-mock-client:
    name: Test Mock Client Connection
    needs: test-patcher
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: ${{ !inputs.skip_boot_test }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python Dependencies
        run: |
          pip install aioquic cryptography

      - name: Download Patched JAR
        uses: actions/download-artifact@v4
        with:
          name: patched-server-jar
          path: server

      - name: Cache Assets.zip
        id: cache-assets
        uses: actions/cache@v4
        with:
          path: server/Assets.zip
          key: hytale-assets-v1
          restore-keys: |
            hytale-assets-

      - name: Download Assets
        if: steps.cache-assets.outputs.cache-hit != 'true'
        working-directory: server
        run: |
          echo "Downloading Assets.zip (not cached)..."
          curl -sfL "$ASSETS_URL" -o Assets.zip
          ls -lh Assets.zip

      - name: Verify Assets
        working-directory: server
        run: |
          ls -lh Assets.zip
          echo "Assets ready"

      - name: Verify Production Auth Server
        run: |
          echo "Verifying production auth server at $HYTALE_AUTH_URL..."

          # Check JWKS endpoint
          echo "Checking JWKS endpoint..."
          curl -sf "$HYTALE_AUTH_URL/.well-known/jwks.json" | head -10

          # Check health endpoint
          echo ""
          echo "Checking health endpoint..."
          curl -sf "$HYTALE_AUTH_URL/health" || echo "Health check returned non-200"

          echo ""
          echo "Production auth server is reachable"

      - name: Fetch Server Tokens from Production Auth
        run: |
          echo "Fetching server tokens from $HYTALE_AUTH_URL..."

          # Generate server ID for this CI run
          SERVER_ID="ci-test-$(date +%s)-$RANDOM"
          SERVER_NAME="CI Test Server"

          RESPONSE=$(curl -sf -X POST "$HYTALE_AUTH_URL/server/auto-auth" \
            -H "Content-Type: application/json" \
            -d "{\"server_id\": \"$SERVER_ID\", \"server_name\": \"$SERVER_NAME\"}")

          echo "Response received"

          # Extract tokens
          SESSION_TOKEN=$(echo "$RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin).get('sessionToken', ''))")
          IDENTITY_TOKEN=$(echo "$RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin).get('identityToken', ''))")

          if [ -z "$SESSION_TOKEN" ] || [ -z "$IDENTITY_TOKEN" ]; then
            echo "Failed to get tokens from auth server"
            echo "Response: $RESPONSE"
            exit 1
          fi

          echo "Session token: [received]"
          echo "Identity token: [received]"

          # Save for later steps
          echo "HYTALE_SERVER_SESSION_TOKEN=$SESSION_TOKEN" >> $GITHUB_ENV
          echo "HYTALE_SERVER_IDENTITY_TOKEN=$IDENTITY_TOKEN" >> $GITHUB_ENV

      - name: Start Game Server
        working-directory: server
        run: |
          export HYTALE_AUTH_DOMAIN="$HYTALE_AUTH_DOMAIN"

          # Create isolated data directory
          mkdir -p universe_ci
          echo "Using isolated data directory: universe_ci"

          echo "Starting Hytale server..."
          java -Xmx2G \
            -jar HytaleServerPatched.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5520 \
            --universe universe_ci \
            --auth-mode authenticated \
            --disable-sentry \
            --session-token "$HYTALE_SERVER_SESSION_TOKEN" \
            --identity-token "$HYTALE_SERVER_IDENTITY_TOKEN" \
            2>&1 | tee server.log &

          SERVER_PID=$!
          echo $SERVER_PID > server.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Match actual log: "Hytale Server Booted!"
            if grep -qi "Server Booted" server.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            # Check if booted after timeout
            if grep -qi "Server Booted" server.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server.log
              exit 1
            fi
          fi

      - name: Get F2P Player Token
        run: |
          echo "Getting F2P player token from production auth..."

          # Create a new game session for test player
          TEST_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          TEST_USERNAME="CITestPlayer"

          RESPONSE=$(curl -sf -X POST "$HYTALE_AUTH_URL/game-session/new" \
            -H "Content-Type: application/json" \
            -d "{\"uuid\": \"$TEST_UUID\", \"username\": \"$TEST_USERNAME\"}" 2>/dev/null || echo "{}")

          # identityToken is the player's auth token
          PLAYER_TOKEN=$(echo "$RESPONSE" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('identityToken') or d.get('token', ''))" 2>/dev/null || echo "")

          if [ -z "$PLAYER_TOKEN" ]; then
            echo "::warning::Could not get player token"
            echo "Response: $RESPONSE"
          else
            echo "Player token received for $TEST_USERNAME"
          fi

          # Extract UUID from token for correct matching
          TOKEN_UUID=$(echo "$PLAYER_TOKEN" | cut -d. -f2 | python3 -c "
          import sys, base64, json
          payload = sys.stdin.read().strip()
          payload += '=' * (4 - len(payload) % 4)
          try:
              data = json.loads(base64.urlsafe_b64decode(payload))
              print(data.get('sub', ''))
          except:
              print('')
          " 2>/dev/null || echo "")

          if [ -n "$TOKEN_UUID" ]; then
            echo "Extracted UUID from token: $TOKEN_UUID"
            TEST_UUID="$TOKEN_UUID"
          fi

          echo "TEST_UUID=$TEST_UUID" >> $GITHUB_ENV
          echo "TEST_USERNAME=$TEST_USERNAME" >> $GITHUB_ENV
          echo "PLAYER_TOKEN=$PLAYER_TOKEN" >> $GITHUB_ENV

      - name: Run Mock Client Tests
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          # Record log position before tests
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 1: Valid Token Connection ==="
          echo "UUID: $TEST_UUID"
          echo "Username: $TEST_USERNAME"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$TEST_UUID" \
            --username "$TEST_USERNAME" \
            --token "$PLAYER_TOKEN" \
            --timeout 5 || true

          sleep 2

          # Check for success (no errors, auth grant obtained)
          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          if echo "$NEW_LOGS" | grep -qiE "Server session token not available|authentication unavailable|UUID mismatch|Invalid identity token"; then
            echo "::error::Test 1 FAILED - Error found in logs"
            echo "$NEW_LOGS" | grep -iE "SEVERE|error|unavailable|mismatch|Invalid" | head -5
            TESTS_FAILED=$((TESTS_FAILED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant"; then
            echo "Test 1 PASSED - Auth grant obtained"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::warning::Test 1 INCONCLUSIVE - Check logs"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 2: Invalid Token Connection ==="
          INVALID_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $INVALID_UUID"
          echo "Username: FakePlayer"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$INVALID_UUID" \
            --username "FakePlayer" \
            --token "invalid.fake.token" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          # Check for token rejection - supports both old messages (signature validation) and new (JWT parsing errors from Omni-Auth)
          if echo "$NEW_LOGS" | grep -qiE "invalid signature|token.*invalid|validation failed|ParseException|Invalid JSON"; then
            echo "Test 2 PASSED - Invalid token correctly rejected"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::error::Test 2 FAILED - Invalid token not rejected"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 3: No Token (Anonymous) ==="
          ANON_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $ANON_UUID"
          echo "Username: AnonPlayer"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$ANON_UUID" \
            --username "AnonPlayer" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          if echo "$NEW_LOGS" | grep -qiE "requires authentication|Rejecting development"; then
            echo "Test 3 PASSED - Anonymous connection correctly rejected"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::error::Test 3 FAILED - Anonymous not rejected"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 4: Omni-Auth Valid Self-Signed Token ==="
          echo "Testing decentralized authentication with embedded JWK (RFC 7515)"
          OMNI_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $OMNI_UUID"
          echo "Username: OmniPlayer"

          # Generate valid Omni-Auth token with embedded JWK
          OMNI_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$OMNI_UUID" \
            --username "OmniPlayer" \
            --issuer "http://127.0.0.1:12345")

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$OMNI_UUID" \
            --username "OmniPlayer" \
            --token "$OMNI_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          # With TRUST_ALL_ISSUERS=true (default), valid self-signed tokens should be accepted
          if echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant|Omni-Auth"; then
            echo "Test 4 PASSED - Omni-Auth token accepted (decentralized auth working)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "embedded.*JWK|transient.*key"; then
            echo "Test 4 PASSED - Omni-Auth JWK extraction working"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            # Omni-Auth might not be enabled, treat as warning not failure
            echo "::warning::Test 4 INCONCLUSIVE - Omni-Auth may not be enabled"
            echo "Check logs for: embedded JWK, transient key, or Omni-Auth messages"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 5: Omni-Auth Invalid Signature ==="
          echo "Testing that corrupted self-signed tokens are rejected"
          OMNI_BAD_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $OMNI_BAD_UUID"
          echo "Username: BadOmniPlayer"

          # Generate Omni-Auth token with invalid signature
          OMNI_BAD_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$OMNI_BAD_UUID" \
            --username "BadOmniPlayer" \
            --issuer "http://127.0.0.1:54321" \
            --invalid-sig)

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$OMNI_BAD_UUID" \
            --username "BadOmniPlayer" \
            --token "$OMNI_BAD_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          # Invalid signature should be rejected regardless of TRUST_ALL_ISSUERS
          if echo "$NEW_LOGS" | grep -qiE "signature.*invalid|verification failed|invalid signature|ParseException|Invalid JSON"; then
            echo "Test 5 PASSED - Invalid Omni-Auth signature correctly rejected"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Disconnect|rejected|error"; then
            echo "Test 5 PASSED - Bad token rejected (check specific error in logs)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::warning::Test 5 INCONCLUSIVE - Could not verify signature rejection"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== WITH-TOKENS Mode Results ==="
          echo "Passed: $TESTS_PASSED / 5"
          echo "Failed: $TESTS_FAILED / 5"

          # Save for final results
          echo "WITH_TOKENS_FAILED=$TESTS_FAILED" >> $GITHUB_ENV

          echo ""
          echo "=== Server Connection Logs (with-tokens) ==="
          grep -iE "connect|auth|DualAuth|grant|Omni|embedded|transient" server/server.log | tail -30 || echo "No connection logs found"

      - name: Stop Server (with-tokens)
        run: |
          echo "Stopping with-tokens server..."
          if [ -f server/server.pid ]; then
            kill $(cat server/server.pid) 2>/dev/null || true
            sleep 1
            kill -9 $(cat server/server.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerPatched.jar 2>/dev/null || true
          sleep 2

      - name: Start Server (no-tokens mode)
        working-directory: server
        run: |
          # Create separate data directory for no-tokens test
          rm -rf universe_no_tokens
          mkdir -p universe_no_tokens
          echo "Using isolated data directory: universe_no_tokens"

          echo "Starting Hytale server WITHOUT tokens (no-tokens mode)..."
          java -Xmx2G \
            -jar HytaleServerPatched.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5521 \
            --universe universe_no_tokens \
            --auth-mode authenticated \
            --disable-sentry \
            2>&1 | tee server_no_tokens.log &

          SERVER_PID=$!
          echo $SERVER_PID > server_no_tokens.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if grep -qi "Server Booted" server_no_tokens.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server_no_tokens.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server_no_tokens.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            if grep -qi "Server Booted" server_no_tokens.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server_no_tokens.log
              exit 1
            fi
          fi

      - name: Run Mock Client Tests (no-tokens mode)
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          LOG_LINES_BEFORE=$(wc -l < server/server_no_tokens.log 2>/dev/null | tr -d ' ')

          echo "=== Test 1: Valid Token Connection (no-tokens server) ==="
          echo "Testing DualAuth patcher auto-fetch feature - should auto-fetch server identity from F2P auth"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5521 \
            --uuid "$TEST_UUID" \
            --username "$TEST_USERNAME" \
            --token "$PLAYER_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server_no_tokens.log)
          # In no-tokens mode, DualAuth patcher should auto-fetch server identity from F2P auth
          # This tests that the patcher's auto-fetch feature works correctly
          if echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant"; then
            echo "Test 1 PASSED - DualAuth patcher auto-fetched server identity"
            if echo "$NEW_LOGS" | grep -qiE "F2P issuer detected|Replacing serverIdentityToken"; then
              echo "  (Confirmed: F2P identity auto-fetch worked)"
            fi
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Server session token not available|authentication unavailable"; then
            echo "Test 1 FAILED - DualAuth patcher should auto-fetch but got error"
            echo "::error::DualAuth auto-fetch feature not working"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          else
            echo "::warning::Test 1 INCONCLUSIVE"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== NO-TOKENS Mode Results ==="
          echo "Passed: $TESTS_PASSED / 1"
          echo "Failed: $TESTS_FAILED / 1"

          NO_TOKENS_FAILED=$TESTS_FAILED

          echo ""
          echo "=== Server Connection Logs (no-tokens) ==="
          grep -iE "connect|auth|SEVERE|unavailable" server/server_no_tokens.log | tail -20 || echo "No connection logs found"

          # Save result for final check
          echo "NO_TOKENS_FAILED=$NO_TOKENS_FAILED" >> $GITHUB_ENV

      - name: Final Results
        env:
          WITH_TOKENS_FAILED: ${{ env.WITH_TOKENS_FAILED || '0' }}
        run: |
          echo ""
          echo "=============================================="
          echo "  Final Test Summary"
          echo "=============================================="
          echo ""
          echo "WITH-TOKENS mode: $( [ \"$WITH_TOKENS_FAILED\" = \"0\" ] && echo 'PASSED' || echo 'FAILED' )"
          echo "NO-TOKENS mode: $( [ \"$NO_TOKENS_FAILED\" = \"0\" ] && echo 'PASSED' || echo 'FAILED' )"
          echo ""

          TOTAL_FAILED=$((${WITH_TOKENS_FAILED:-0} + ${NO_TOKENS_FAILED:-0}))
          if [ $TOTAL_FAILED -gt 0 ]; then
            echo "Overall: SOME TESTS FAILED"
            exit 1
          fi
          echo "Overall: ALL TESTS PASSED"

      - name: Stop Server
        if: always()
        run: |
          if [ -f server/server.pid ]; then
            kill $(cat server/server.pid) 2>/dev/null || true
            kill -9 $(cat server/server.pid) 2>/dev/null || true
          fi
          if [ -f server/server_no_tokens.pid ]; then
            kill $(cat server/server_no_tokens.pid) 2>/dev/null || true
            kill -9 $(cat server/server_no_tokens.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerPatched.jar 2>/dev/null || true

      - name: Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mock-client-test-logs
          path: |
            server/server.log
            server/server_no_tokens.log
          retention-days: 7
