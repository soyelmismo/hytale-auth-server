name: Test DualAuth Patcher

on:
  push:
    paths:
      - 'dualauth-agent/**'
      - '.github/workflows/test-patcher.yml'
      - '.github/scripts/**'
  pull_request:
    paths:
      - 'dualauth-agent/**'
      - '.github/scripts/**'
  workflow_dispatch:
    inputs:
      server_jar_url:
        description: 'Server JAR URL'
        default: 'https://download.sanasol.ws/download/HytaleServerOriginal.jar'
        required: false
      assets_url:
        description: 'Assets.zip URL'
        default: 'https://download.sanasol.ws/download/Assets.zip'
        required: false
      skip_boot_test:
        description: 'Skip server boot test'
        type: boolean
        default: false

env:
  SERVER_JAR_URL: ${{ inputs.server_jar_url || 'https://download.sanasol.ws/download/HytaleServerOriginal.jar' }}
  ASSETS_URL: ${{ inputs.assets_url || 'https://download.sanasol.ws/download/Assets.zip' }}
  HYTALE_AUTH_DOMAIN: 'auth.sanasol.ws'
  HYTALE_AUTH_URL: 'https://auth.sanasol.ws'

jobs:
  build-agent:
    name: Build DualAuth Agent & Download Server
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      version: ${{ steps.get_version.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'gradle'

      - name: Build Agent
        working-directory: dualauth-agent
        run: |
          chmod +x ./gradlew
          ./gradlew clean shadowJar --stacktrace --info
          ls -la build/libs/*.jar

      - name: Extract version
        id: get_version
        working-directory: dualauth-agent
        run: |
          VERSION=$(grep "version =" build.gradle | cut -d"'" -f2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Download Original Server JAR
        run: |
          echo "Downloading server JAR from: $SERVER_JAR_URL"
          curl -sfL "$SERVER_JAR_URL" -o HytaleServerOriginal.jar
          ls -lh HytaleServerOriginal.jar

      - name: Upload Agent Artifact
        uses: actions/upload-artifact@v4
        with:
          name: dualauth-agent
          path: dualauth-agent/build/libs/dualauth-agent.jar
          retention-days: 7

      - name: Upload Server JAR Artifact
        uses: actions/upload-artifact@v4
        with:
          name: server-jar
          path: HytaleServerOriginal.jar
          retention-days: 7

  test-server-boot:
    name: Test Server Boot
    needs: build-agent
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: ${{ !inputs.skip_boot_test }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 25
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '25'

      - name: Download Agent & Server
        uses: actions/download-artifact@v4
        with:
          path: server
          merge-multiple: true

      - name: Cache Assets.zip
        id: cache-assets
        uses: actions/cache@v4
        with:
          path: server/Assets.zip
          key: hytale-assets-v1
          restore-keys: |
            hytale-assets-

      - name: Download Assets
        if: steps.cache-assets.outputs.cache-hit != 'true'
        working-directory: server
        run: |
          echo "Downloading Assets.zip (not cached)..."
          curl -sfL "$ASSETS_URL" -o Assets.zip
          ls -lh Assets.zip

      - name: Verify Assets
        working-directory: server
        run: |
          ls -lh Assets.zip
          echo "Assets ready"

      - name: Verify Production Auth Server
        run: |
          echo "Verifying production auth server at $HYTALE_AUTH_URL..."
          curl -sf "$HYTALE_AUTH_URL/.well-known/jwks.json" | head -5
          echo ""
          echo "Production auth server is reachable"

      - name: Test Server Boot
        working-directory: server
        timeout-minutes: 3
        run: |
          echo "Starting Hytale server boot test (no tokens)..."
          echo "Testing for bytecode patching errors (NoSuchFieldError, etc.)"
          echo ""

          java -Xmx2G -javaagent:dualauth-agent.jar -jar HytaleServerOriginal.jar \
            --assets Assets.zip \
            --bare \
            --disable-sentry \
            2>&1 | tee server.log &

          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"

          # Wait for boot or error (30s timeout)
          TIMEOUT=30
          ELAPSED=0
          SUCCESS=false
          BYTECODE_ERROR=false

          echo "Monitoring server boot (max ${TIMEOUT}s)..."

          while kill -0 $SERVER_PID 2>/dev/null; do
            sleep 2
            ELAPSED=$((ELAPSED + 2))

            # Check for bytecode errors (patcher compatibility issues)
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server.log 2>/dev/null; then
              echo ""
              echo "::error::Bytecode patching error detected!"
              grep -E "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server.log | head -5
              BYTECODE_ERROR=true
              kill $SERVER_PID 2>/dev/null || true
              break
            fi

            # Check for successful boot - match actual log: "Hytale Server Booted!"
            if grep -qi "Server Booted" server.log 2>/dev/null; then
              echo "Server booted successfully!"
              SUCCESS=true
              # Force kill immediately
              kill $SERVER_PID 2>/dev/null || true
              sleep 1
              kill -9 $SERVER_PID 2>/dev/null || true
              break
            fi

            # Progress
            if [ $((ELAPSED % 10)) -eq 0 ]; then
              echo "... waiting ($ELAPSED/${TIMEOUT}s)"
            fi

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "Timeout reached"
              # Check if we got far enough
              if grep -qi "Server Booted" server.log 2>/dev/null; then
                echo "Server booted (detected after timeout)"
                SUCCESS=true
              elif grep -q "Plugin manager started\|Universe ready" server.log 2>/dev/null; then
                echo "Server reached plugin stage - patcher is compatible"
                SUCCESS=true
              fi
              break
            fi
          done

          # Force kill server
          echo "Stopping server..."
          kill $SERVER_PID 2>/dev/null || true
          sleep 1
          kill -9 $SERVER_PID 2>/dev/null || true
          pkill -9 -f HytaleServerOriginal.jar 2>/dev/null || true

          echo ""
          echo "=== Server Log (last 20 lines) ==="
          tail -20 server.log

          echo ""
          echo "=== DualAuth Log Messages ==="
          grep -i "DualAuth" server.log | head -10 || echo "No DualAuth messages found"

          echo ""
          echo "=== Test Result ==="
          if [ "$BYTECODE_ERROR" = true ]; then
            echo "FAILED: Bytecode patching error"
            exit 1
          elif [ "$SUCCESS" = true ]; then
            echo "PASSED: Server booted without bytecode errors"
            exit 0
          else
            echo "UNKNOWN: Check logs for details"
            exit 0
          fi

      - name: Upload Server Log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: server-boot-log
          path: server/server.log
          retention-days: 7

  test-mock-client:
    name: Test Mock Client Connection
    needs: build-agent
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: ${{ !inputs.skip_boot_test }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 25
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '25'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python Dependencies
        run: |
          pip install aioquic cryptography

      - name: Download Agent & Server
        uses: actions/download-artifact@v4
        with:
          path: server
          merge-multiple: true

      - name: Cache Assets.zip
        id: cache-assets
        uses: actions/cache@v4
        with:
          path: server/Assets.zip
          key: hytale-assets-v1
          restore-keys: |
            hytale-assets-

      - name: Download Assets
        if: steps.cache-assets.outputs.cache-hit != 'true'
        working-directory: server
        run: |
          echo "Downloading Assets.zip (not cached)..."
          curl -sfL "$ASSETS_URL" -o Assets.zip
          ls -lh Assets.zip

      - name: Verify Assets
        working-directory: server
        run: |
          ls -lh Assets.zip
          echo "Assets ready"

      - name: Verify Production Auth Server
        run: |
          echo "Verifying production auth server at $HYTALE_AUTH_URL..."

          # Check JWKS endpoint
          echo "Checking JWKS endpoint..."
          curl -sf "$HYTALE_AUTH_URL/.well-known/jwks.json" | head -10

          # Check health endpoint
          echo ""
          echo "Checking health endpoint..."
          curl -sf "$HYTALE_AUTH_URL/health" || echo "Health check returned non-200"

          echo ""
          echo "Production auth server is reachable"

      - name: Fetch Server Tokens from Production Auth
        run: |
          echo "Fetching server tokens from $HYTALE_AUTH_URL..."

          # Generate server ID for this CI run
          SERVER_ID="ci-test-$(date +%s)-$RANDOM"
          SERVER_NAME="CI Test Server"

          RESPONSE=$(curl -sf -X POST "$HYTALE_AUTH_URL/server/auto-auth" \
            -H "Content-Type: application/json" \
            -d "{\"server_id\": \"$SERVER_ID\", \"server_name\": \"$SERVER_NAME\"}")

          echo "Response received"

          # Extract tokens
          SESSION_TOKEN=$(echo "$RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin).get('sessionToken', ''))")
          IDENTITY_TOKEN=$(echo "$RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin).get('identityToken', ''))")

          if [ -z "$SESSION_TOKEN" ] || [ -z "$IDENTITY_TOKEN" ]; then
            echo "Failed to get tokens from auth server"
            echo "Response: $RESPONSE"
            exit 1
          fi

          echo "Session token: [received]"
          echo "Identity token: [received]"

          # Save for later steps
          echo "HYTALE_SERVER_SESSION_TOKEN=$SESSION_TOKEN" >> $GITHUB_ENV
          echo "HYTALE_SERVER_IDENTITY_TOKEN=$IDENTITY_TOKEN" >> $GITHUB_ENV

      - name: Start Game Server
        working-directory: server
        run: |
          export HYTALE_AUTH_DOMAIN="$HYTALE_AUTH_DOMAIN"

          # Create isolated data directory
          mkdir -p universe_ci
          echo "Using isolated data directory: universe_ci"

          echo "Starting Hytale server..."
          java -Xmx2G \
            -javaagent:dualauth-agent.jar \
            -jar HytaleServerOriginal.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5520 \
            --universe universe_ci \
            --auth-mode authenticated \
            --disable-sentry \
            --session-token "$HYTALE_SERVER_SESSION_TOKEN" \
            --identity-token "$HYTALE_SERVER_IDENTITY_TOKEN" \
            2>&1 | tee server.log &

          SERVER_PID=$!
          echo $SERVER_PID > server.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Match actual log: "Hytale Server Booted!"
            if grep -qi "Server Booted" server.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            # Check if booted after timeout
            if grep -qi "Server Booted" server.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server.log
              exit 1
            fi
          fi

      - name: Get F2P Player Token
        run: |
          echo "Getting F2P player token from production auth..."

          # Create a new game session for test player
          TEST_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          TEST_USERNAME="CITestPlayer"

          RESPONSE=$(curl -sf -X POST "$HYTALE_AUTH_URL/game-session/new" \
            -H "Content-Type: application/json" \
            -d "{\"uuid\": \"$TEST_UUID\", \"username\": \"$TEST_USERNAME\"}" 2>/dev/null || echo "{}")

          # identityToken is the player's auth token
          PLAYER_TOKEN=$(echo "$RESPONSE" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('identityToken') or d.get('token', ''))" 2>/dev/null || echo "")

          if [ -z "$PLAYER_TOKEN" ]; then
            echo "::warning::Could not get player token"
            echo "Response: $RESPONSE"
          else
            echo "Player token received for $TEST_USERNAME"
          fi

          # Extract UUID from token for correct matching
          TOKEN_UUID=$(echo "$PLAYER_TOKEN" | cut -d. -f2 | python3 -c "
          import sys, base64, json
          payload = sys.stdin.read().strip()
          payload += '=' * (4 - len(payload) % 4)
          try:
              data = json.loads(base64.urlsafe_b64decode(payload))
              print(data.get('sub', ''))
          except:
              print('')
          " 2>/dev/null || echo "")

          if [ -n "$TOKEN_UUID" ]; then
            echo "Extracted UUID from token: $TOKEN_UUID"
            TEST_UUID="$TOKEN_UUID"
          fi

          echo "TEST_UUID=$TEST_UUID" >> $GITHUB_ENV
          echo "TEST_USERNAME=$TEST_USERNAME" >> $GITHUB_ENV
          echo "PLAYER_TOKEN=$PLAYER_TOKEN" >> $GITHUB_ENV

      - name: Run Mock Client Tests
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          # Record log position before tests
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 1: Valid Token Connection ==="
          echo "UUID: $TEST_UUID"
          echo "Username: $TEST_USERNAME"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$TEST_UUID" \
            --username "$TEST_USERNAME" \
            --token "$PLAYER_TOKEN" \
            --timeout 5 || true

          sleep 2

          # Check for success (no errors, auth grant obtained)
          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          if echo "$NEW_LOGS" | grep -qiE "Server session token not available|authentication unavailable|UUID mismatch|Invalid identity token"; then
            echo "::error::Test 1 FAILED - Error found in logs"
            echo "$NEW_LOGS" | grep -iE "SEVERE|error|unavailable|mismatch|Invalid" | head -5
            TESTS_FAILED=$((TESTS_FAILED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant"; then
            echo "Test 1 PASSED - Auth grant obtained"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::warning::Test 1 INCONCLUSIVE - Check logs"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 2: Invalid Token Connection ==="
          INVALID_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $INVALID_UUID"
          echo "Username: FakePlayer"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$INVALID_UUID" \
            --username "FakePlayer" \
            --token "invalid.fake.token" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          # Check for token rejection - supports both old messages (signature validation) and new (JWT parsing errors from Omni-Auth)
          if echo "$NEW_LOGS" | grep -qiE "invalid signature|token.*invalid|validation failed|ParseException|Invalid JSON"; then
            echo "Test 2 PASSED - Invalid token correctly rejected"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::error::Test 2 FAILED - Invalid token not rejected"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 3: No Token (Anonymous) ==="
          ANON_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $ANON_UUID"
          echo "Username: AnonPlayer"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$ANON_UUID" \
            --username "AnonPlayer" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          if echo "$NEW_LOGS" | grep -qiE "requires authentication|Rejecting development"; then
            echo "Test 3 PASSED - Anonymous connection correctly rejected"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::error::Test 3 FAILED - Anonymous not rejected"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 4: Omni-Auth Valid Self-Signed Token ==="
          echo "Testing decentralized authentication with embedded JWK (RFC 7515)"
          OMNI_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $OMNI_UUID"
          echo "Username: OmniPlayer"

          # Generate valid Omni-Auth token with embedded JWK
          OMNI_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$OMNI_UUID" \
            --username "OmniPlayer" \
            --issuer "http://127.0.0.1:12345")

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$OMNI_UUID" \
            --username "OmniPlayer" \
            --token "$OMNI_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          # With TRUST_ALL_ISSUERS=true (default), valid self-signed tokens should be accepted
          if echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant|Omni-Auth"; then
            echo "Test 4 PASSED - Omni-Auth token accepted (decentralized auth working)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "embedded.*JWK|transient.*key"; then
            echo "Test 4 PASSED - Omni-Auth JWK extraction working"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            # Omni-Auth might not be enabled, treat as warning not failure
            echo "::warning::Test 4 INCONCLUSIVE - Omni-Auth may not be enabled"
            echo "Check logs for: embedded JWK, transient key, or Omni-Auth messages"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server.log 2>/dev/null | tr -d ' ')

          echo "=== Test 5: Omni-Auth Invalid Signature ==="
          echo "Testing that corrupted self-signed tokens are rejected"
          OMNI_BAD_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $OMNI_BAD_UUID"
          echo "Username: BadOmniPlayer"

          # Generate Omni-Auth token with invalid signature
          OMNI_BAD_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$OMNI_BAD_UUID" \
            --username "BadOmniPlayer" \
            --issuer "http://127.0.0.1:54321" \
            --invalid-sig)

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5520 \
            --uuid "$OMNI_BAD_UUID" \
            --username "BadOmniPlayer" \
            --token "$OMNI_BAD_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server.log)
          # Invalid signature should be rejected regardless of TRUST_ALL_ISSUERS
          if echo "$NEW_LOGS" | grep -qiE "signature.*invalid|verification failed|invalid signature|ParseException|Invalid JSON"; then
            echo "Test 5 PASSED - Invalid Omni-Auth signature correctly rejected"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Disconnect|rejected|error"; then
            echo "Test 5 PASSED - Bad token rejected (check specific error in logs)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::warning::Test 5 INCONCLUSIVE - Could not verify signature rejection"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== WITH-TOKENS Mode Results ==="
          echo "Passed: $TESTS_PASSED / 5"
          echo "Failed: $TESTS_FAILED / 5"

          # Save for final results
          echo "WITH_TOKENS_FAILED=$TESTS_FAILED" >> $GITHUB_ENV

          echo ""
          echo "=== Server Connection Logs (with-tokens) ==="
          grep -iE "connect|auth|DualAuth|grant|Omni|embedded|transient" server/server.log | tail -30 || echo "No connection logs found"

      - name: Stop Server (with-tokens)
        run: |
          echo "Stopping with-tokens server..."
          if [ -f server/server.pid ]; then
            kill $(cat server/server.pid) 2>/dev/null || true
            sleep 1
            kill -9 $(cat server/server.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerOriginal.jar 2>/dev/null || true
          sleep 2

      # ==========================================
      # STRICT MODE TESTS (TRUST_ALL_ISSUERS=false)
      # ==========================================

      - name: Start Server (strict mode - trust disabled, WITH CLI tokens)
        working-directory: server
        run: |
          # Create separate data directory for strict mode test
          rm -rf universe_strict
          mkdir -p universe_strict
          echo "Using isolated data directory: universe_strict"

          echo "Starting Hytale server with HYTALE_TRUST_ALL_ISSUERS=false (strict mode)..."
          echo "IMPORTANT: Testing WITH CLI tokens to verify server can validate its own identity"
          HYTALE_TRUST_ALL_ISSUERS=false \
          java -Xmx2G \
            -javaagent:dualauth-agent.jar \
            -jar HytaleServerOriginal.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5522 \
            --universe universe_strict \
            --auth-mode authenticated \
            --disable-sentry \
            --session-token "$HYTALE_SERVER_SESSION_TOKEN" \
            --identity-token "$HYTALE_SERVER_IDENTITY_TOKEN" \
            2>&1 | tee server_strict.log &

          SERVER_PID=$!
          echo $SERVER_PID > server_strict.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if grep -qi "Server Booted" server_strict.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server_strict.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server_strict.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            if grep -qi "Server Booted" server_strict.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server_strict.log
              exit 1
            fi
          fi

      - name: Run Mock Client Tests (strict mode - trust disabled)
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          LOG_LINES_BEFORE=$(wc -l < server/server_strict.log 2>/dev/null | tr -d ' ')

          echo "=== Test 6: Omni-Auth Token REJECTED (strict mode, no trusted issuers) ==="
          echo "Testing that self-signed Omni-Auth tokens are REJECTED when TRUST_ALL_ISSUERS=false"
          STRICT_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $STRICT_UUID"
          echo "Username: StrictTestPlayer"

          # Generate valid Omni-Auth token (should be rejected in strict mode)
          STRICT_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$STRICT_UUID" \
            --username "StrictTestPlayer" \
            --issuer "http://127.0.0.1:12345")

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5522 \
            --uuid "$STRICT_UUID" \
            --username "StrictTestPlayer" \
            --token "$STRICT_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server_strict.log)
          # In strict mode with no trusted issuers, self-signed Omni-Auth tokens should be REJECTED
          if echo "$NEW_LOGS" | grep -qiE "Omni-Auth rejected.*TRUST_ALL_ISSUERS=false|TRUST_ALL_ISSUERS=false.*rejected"; then
            echo "Test 6 PASSED - Omni-Auth token correctly rejected (TRUST_ALL_ISSUERS=false)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "untrusted issuer|issuer not trusted|issuer.*not.*allowed"; then
            echo "Test 6 PASSED - Omni-Auth token correctly rejected (untrusted issuer)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Identity token validation failed|Invalid.*identity.*token"; then
            echo "Test 6 PASSED - Token rejected in strict mode"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant"; then
            echo "::error::Test 6 FAILED - Token should be REJECTED in strict mode but was accepted"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          else
            echo "::warning::Test 6 INCONCLUSIVE - Could not determine if token was rejected"
            echo "Logs:"
            echo "$NEW_LOGS" | tail -15
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== STRICT MODE (trust disabled) Results ==="
          echo "Passed: $TESTS_PASSED / 1"
          echo "Failed: $TESTS_FAILED / 1"

          echo "STRICT_MODE_FAILED=$TESTS_FAILED" >> $GITHUB_ENV

          echo ""
          echo "=== Server Connection Logs (strict mode) ==="
          grep -iE "connect|auth|DualAuth|issuer|trust|reject" server/server_strict.log | tail -20 || echo "No connection logs found"

      - name: Stop Server (strict mode)
        run: |
          echo "Stopping strict mode server..."
          if [ -f server/server_strict.pid ]; then
            kill $(cat server/server_strict.pid) 2>/dev/null || true
            sleep 1
            kill -9 $(cat server/server_strict.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerOriginal.jar 2>/dev/null || true
          sleep 2

      # ==========================================
      # STRICT MODE WITHOUT TOKENS (pure strict)
      # ==========================================

      - name: Start Server (strict mode - NO tokens, NO allowlist)
        working-directory: server
        run: |
          # Create separate data directory for pure strict mode test
          rm -rf universe_strict_pure
          mkdir -p universe_strict_pure
          echo "Using isolated data directory: universe_strict_pure"

          echo "Starting Hytale server with HYTALE_TRUST_ALL_ISSUERS=false (pure strict mode)..."
          echo "NO CLI tokens, NO trusted issuer allowlist"
          echo "Expected: Server boots fine, but Omni-Auth players should be REJECTED"
          HYTALE_TRUST_ALL_ISSUERS=false \
          java -Xmx2G \
            -javaagent:dualauth-agent.jar \
            -jar HytaleServerOriginal.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5524 \
            --universe universe_strict_pure \
            --auth-mode authenticated \
            --disable-sentry \
            2>&1 | tee server_strict_pure.log &

          SERVER_PID=$!
          echo $SERVER_PID > server_strict_pure.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if grep -qi "Server Booted" server_strict_pure.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server_strict_pure.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server_strict_pure.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            if grep -qi "Server Booted" server_strict_pure.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server_strict_pure.log
              exit 1
            fi
          fi

      - name: Test Omni-Auth Rejection (pure strict mode)
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          LOG_LINES_BEFORE=$(wc -l < server/server_strict_pure.log 2>/dev/null | tr -d ' ')

          echo "=== Test 9: Omni-Auth Should Be REJECTED in Pure Strict Mode ==="
          echo "With TRUST_ALL_ISSUERS=false and no allowlist, Omni-Auth tokens should be rejected"

          # Generate Omni-Auth token
          OMNI_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          OMNI_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$OMNI_UUID" \
            --username "RejectedPlayer" \
            --issuer "http://127.0.0.1:12345")

          echo "Attempting connection with Omni-Auth token (should be rejected)..."
          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5524 \
            --uuid "$OMNI_UUID" \
            --username "RejectedPlayer" \
            --token "$OMNI_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server_strict_pure.log)
          # In pure strict mode, Omni-Auth should be rejected
          if echo "$NEW_LOGS" | grep -qiE "not trusted|untrusted|issuer.*reject|isValidIssuer.*false|Invalid issuer"; then
            echo "Test 9 PASSED - Omni-Auth correctly REJECTED in pure strict mode"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Disconnect|auth.*fail|reject"; then
            echo "Test 9 PASSED - Player rejected (strict mode working)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "auth.*grant|grant.*success"; then
            echo "::error::Test 9 FAILED - Omni-Auth should be REJECTED in pure strict mode"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          else
            echo "::warning::Test 9 INCONCLUSIVE - Check logs for rejection pattern"
            echo "Recent logs:"
            echo "$NEW_LOGS" | tail -10
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== Pure Strict Mode Results ==="
          echo "Passed: $TESTS_PASSED / 1"
          echo "Failed: $TESTS_FAILED / 1"

          echo "PURE_STRICT_FAILED=$TESTS_FAILED" >> $GITHUB_ENV

          echo ""
          echo "=== Server Connection Logs (pure strict mode) ==="
          grep -iE "connect|auth|DualAuth|issuer|trust|reject" server/server_strict_pure.log | tail -20 || echo "No connection logs found"

      - name: Stop Server (pure strict mode)
        run: |
          echo "Stopping pure strict mode server..."
          if [ -f server/server_strict_pure.pid ]; then
            kill $(cat server/server_strict_pure.pid) 2>/dev/null || true
            sleep 1
            kill -9 $(cat server/server_strict_pure.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerOriginal.jar 2>/dev/null || true
          sleep 2

      - name: Start Server (strict mode - with trusted issuer allowlist)
        working-directory: server
        run: |
          # Create separate data directory for trusted issuer test
          rm -rf universe_trusted
          mkdir -p universe_trusted
          echo "Using isolated data directory: universe_trusted"

          echo "Starting Hytale server with HYTALE_TRUST_ALL_ISSUERS=false and HYTALE_TRUSTED_ISSUERS=127.0.0.1..."
          echo "Note: No CLI tokens - server will auto-fetch F2P tokens only"
          HYTALE_TRUST_ALL_ISSUERS=false \
          HYTALE_TRUSTED_ISSUERS="127.0.0.1,localhost" \
          java -Xmx2G \
            -javaagent:dualauth-agent.jar \
            -jar HytaleServerOriginal.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5523 \
            --universe universe_trusted \
            --auth-mode authenticated \
            --disable-sentry \
            2>&1 | tee server_trusted.log &

          SERVER_PID=$!
          echo $SERVER_PID > server_trusted.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if grep -qi "Server Booted" server_trusted.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server_trusted.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server_trusted.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            if grep -qi "Server Booted" server_trusted.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server_trusted.log
              exit 1
            fi
          fi

      - name: Run Mock Client Tests (strict mode - with trusted issuer)
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          LOG_LINES_BEFORE=$(wc -l < server/server_trusted.log 2>/dev/null | tr -d ' ')

          echo "=== Test 7: Omni-Auth Token ACCEPTED (strict mode, issuer in allowlist) ==="
          echo "Testing that self-signed Omni-Auth tokens are ACCEPTED when issuer matches TRUSTED_ISSUERS"
          TRUSTED_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "UUID: $TRUSTED_UUID"
          echo "Username: TrustedPlayer"

          # Generate valid Omni-Auth token with issuer matching the allowlist
          TRUSTED_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$TRUSTED_UUID" \
            --username "TrustedPlayer" \
            --issuer "http://127.0.0.1:12345")

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5523 \
            --uuid "$TRUSTED_UUID" \
            --username "TrustedPlayer" \
            --token "$TRUSTED_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server_trusted.log)
          # In strict mode with matching trusted issuer, token should be ACCEPTED
          # Check for explicit rejection first (this is a FAILURE case)
          if echo "$NEW_LOGS" | grep -qiE "Omni-Auth rejected|TRUST_ALL_ISSUERS=false.*rejected"; then
            echo "::error::Test 7 FAILED - Omni-Auth rejected even though issuer IS in TRUSTED_ISSUERS list"
            echo "This indicates TRUSTED_ISSUERS is not being checked for Omni-Auth tokens"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant"; then
            echo "Test 7 PASSED - Omni-Auth token accepted (issuer in allowlist)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "untrusted issuer|issuer not trusted"; then
            echo "::error::Test 7 FAILED - Token rejected as untrusted but issuer IS in trusted list"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Identity token validation failed|Invalid.*identity.*token"; then
            echo "::error::Test 7 FAILED - Token validation failed (issuer should have been trusted)"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          else
            echo "::warning::Test 7 INCONCLUSIVE - Could not verify token acceptance"
            echo "Logs:"
            echo "$NEW_LOGS" | tail -15
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          LOG_LINES_BEFORE=$(wc -l < server/server_trusted.log 2>/dev/null | tr -d ' ')

          echo "=== Test 8: JWK Cache Isolation - Multiple Players Same Issuer ==="
          echo "Testing that two players with SAME issuer but DIFFERENT JWK keys both work"
          echo "This verifies the cache isolates keys by PlayerUUID, not just issuer URL"

          # Player A - first connection with unique key
          PLAYER_A_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "Player A UUID: $PLAYER_A_UUID"
          echo "Player A Username: CacheTestPlayerA"

          PLAYER_A_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$PLAYER_A_UUID" \
            --username "CacheTestPlayerA" \
            --issuer "http://127.0.0.1:12345")

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5523 \
            --uuid "$PLAYER_A_UUID" \
            --username "CacheTestPlayerA" \
            --token "$PLAYER_A_TOKEN" \
            --timeout 5 || true

          sleep 1

          # Player B - second connection with DIFFERENT key but SAME issuer
          PLAYER_B_UUID=$(python3 -c "import uuid; print(uuid.uuid4())")
          echo "Player B UUID: $PLAYER_B_UUID"
          echo "Player B Username: CacheTestPlayerB"

          PLAYER_B_TOKEN=$(python3 .github/scripts/generate-omni-token.py \
            --uuid "$PLAYER_B_UUID" \
            --username "CacheTestPlayerB" \
            --issuer "http://127.0.0.1:12345")

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5523 \
            --uuid "$PLAYER_B_UUID" \
            --username "CacheTestPlayerB" \
            --token "$PLAYER_B_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server_trusted.log)

          # Count successful auth grants for both players
          PLAYER_A_SUCCESS=$(echo "$NEW_LOGS" | grep -iE "CacheTestPlayerA.*auth.*grant|auth.*grant.*CacheTestPlayerA|Starting authenticated flow for CacheTestPlayerA" | wc -l)
          PLAYER_B_SUCCESS=$(echo "$NEW_LOGS" | grep -iE "CacheTestPlayerB.*auth.*grant|auth.*grant.*CacheTestPlayerB|Starting authenticated flow for CacheTestPlayerB" | wc -l)

          # Check for signature failures (would indicate cache collision)
          SIGNATURE_ERRORS=$(echo "$NEW_LOGS" | grep -iE "Invalid signature|signature.*failed|verification.*failed" | wc -l)

          echo "Player A auth flow started: $PLAYER_A_SUCCESS"
          echo "Player B auth flow started: $PLAYER_B_SUCCESS"
          echo "Signature errors: $SIGNATURE_ERRORS"

          if [ "$SIGNATURE_ERRORS" -gt 0 ]; then
            echo "::error::Test 8 FAILED - Signature verification failed (possible JWK cache collision)"
            echo "Cache may be returning wrong key for one of the players"
            echo "$NEW_LOGS" | grep -iE "Invalid signature|signature.*failed|verification.*failed"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          elif [ "$PLAYER_A_SUCCESS" -gt 0 ] && [ "$PLAYER_B_SUCCESS" -gt 0 ]; then
            echo "Test 8 PASSED - Both players authenticated with separate JWK keys"
            echo "JWK cache correctly isolates keys by PlayerUUID"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -c "Sending AuthGrant" | grep -q "2"; then
            echo "Test 8 PASSED - Two auth grants sent (both players authenticated)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "::warning::Test 8 INCONCLUSIVE - Could not verify both players authenticated"
            echo "Logs:"
            echo "$NEW_LOGS" | grep -iE "CacheTestPlayer|auth|grant|signature" | tail -20
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== TRUSTED ISSUER MODE Results ==="
          echo "Passed: $TESTS_PASSED / 2"
          echo "Failed: $TESTS_FAILED / 2"

          echo "TRUSTED_ISSUER_FAILED=$TESTS_FAILED" >> $GITHUB_ENV

          echo ""
          echo "=== Server Connection Logs (trusted issuer mode) ==="
          grep -iE "connect|auth|DualAuth|issuer|trust|accept|CacheTest" server/server_trusted.log | tail -30 || echo "No connection logs found"

      - name: Stop Server (trusted issuer mode)
        run: |
          echo "Stopping trusted issuer mode server..."
          if [ -f server/server_trusted.pid ]; then
            kill $(cat server/server_trusted.pid) 2>/dev/null || true
            sleep 1
            kill -9 $(cat server/server_trusted.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerOriginal.jar 2>/dev/null || true
          sleep 2

      - name: Start Server (no-tokens mode)
        working-directory: server
        run: |
          # Create separate data directory for no-tokens test
          rm -rf universe_no_tokens
          mkdir -p universe_no_tokens
          echo "Using isolated data directory: universe_no_tokens"

          echo "Starting Hytale server WITHOUT tokens (no-tokens mode)..."
          java -Xmx2G \
            -javaagent:dualauth-agent.jar \
            -jar HytaleServerOriginal.jar \
            --assets Assets.zip \
            --bind 0.0.0.0:5521 \
            --universe universe_no_tokens \
            --auth-mode authenticated \
            --disable-sentry \
            2>&1 | tee server_no_tokens.log &

          SERVER_PID=$!
          echo $SERVER_PID > server_no_tokens.pid
          echo "Server PID: $SERVER_PID"

          # Wait for server to boot
          echo "Waiting for server to start..."
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if grep -qi "Server Booted" server_no_tokens.log 2>/dev/null; then
              echo "Server is ready!"
              break
            fi
            if grep -qE "NoSuchFieldError|NoSuchMethodError|ClassNotFoundException|VerifyError" server_no_tokens.log 2>/dev/null; then
              echo "Bytecode error - patcher incompatible"
              cat server_no_tokens.log
              exit 1
            fi
            sleep 3
            ELAPSED=$((ELAPSED + 3))
            echo "... waiting ($ELAPSED/$TIMEOUT)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            if grep -qi "Server Booted" server_no_tokens.log 2>/dev/null; then
              echo "Server booted (detected after timeout check)"
            else
              echo "Server did not boot within timeout"
              tail -30 server_no_tokens.log
              exit 1
            fi
          fi

      - name: Run Mock Client Tests (no-tokens mode)
        run: |
          TESTS_PASSED=0
          TESTS_FAILED=0

          LOG_LINES_BEFORE=$(wc -l < server/server_no_tokens.log 2>/dev/null | tr -d ' ')

          echo "=== Test 1: Valid Token Connection (no-tokens server) ==="
          echo "Testing DualAuth patcher auto-fetch feature - should auto-fetch server identity from F2P auth"

          python3 .github/scripts/mock-client.py \
            --host 127.0.0.1 \
            --port 5521 \
            --uuid "$TEST_UUID" \
            --username "$TEST_USERNAME" \
            --token "$PLAYER_TOKEN" \
            --timeout 5 || true

          sleep 2

          NEW_LOGS=$(tail -n +"$LOG_LINES_BEFORE" server/server_no_tokens.log)
          # In no-tokens mode, DualAuth patcher should auto-fetch server identity from F2P auth
          # This tests that the patcher's auto-fetch feature works correctly
          if echo "$NEW_LOGS" | grep -qiE "Successfully obtained authorization grant|Sending AuthGrant"; then
            echo "Test 1 PASSED - DualAuth patcher auto-fetched server identity"
            if echo "$NEW_LOGS" | grep -qiE "F2P issuer detected|Replacing serverIdentityToken"; then
              echo "  (Confirmed: F2P identity auto-fetch worked)"
            fi
            TESTS_PASSED=$((TESTS_PASSED + 1))
          elif echo "$NEW_LOGS" | grep -qiE "Server session token not available|authentication unavailable"; then
            echo "Test 1 FAILED - DualAuth patcher should auto-fetch but got error"
            echo "::error::DualAuth auto-fetch feature not working"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          else
            echo "::warning::Test 1 INCONCLUSIVE"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi

          echo ""
          echo "=== NO-TOKENS Mode Results ==="
          echo "Passed: $TESTS_PASSED / 1"
          echo "Failed: $TESTS_FAILED / 1"

          NO_TOKENS_FAILED=$TESTS_FAILED

          echo ""
          echo "=== Server Connection Logs (no-tokens) ==="
          grep -iE "connect|auth|SEVERE|unavailable" server/server_no_tokens.log | tail -20 || echo "No connection logs found"

          # Save result for final check
          echo "NO_TOKENS_FAILED=$NO_TOKENS_FAILED" >> $GITHUB_ENV

      - name: Final Results
        env:
          WITH_TOKENS_FAILED: ${{ env.WITH_TOKENS_FAILED || '0' }}
          STRICT_MODE_FAILED: ${{ env.STRICT_MODE_FAILED || '0' }}
          TRUSTED_ISSUER_FAILED: ${{ env.TRUSTED_ISSUER_FAILED || '0' }}
        run: |
          echo ""
          echo "=============================================="
          echo "  Final Test Summary"
          echo "=============================================="
          echo ""
          echo "WITH-TOKENS mode (Tests 1-5): $( [ \"$WITH_TOKENS_FAILED\" = \"0\" ] && echo 'PASSED' || echo 'FAILED' )"
          echo "STRICT MODE (Test 6 - trust disabled): $( [ \"$STRICT_MODE_FAILED\" = \"0\" ] && echo 'PASSED' || echo 'FAILED' )"
          echo "TRUSTED ISSUER MODE (Tests 7-8 - allowlist + cache isolation): $( [ \"$TRUSTED_ISSUER_FAILED\" = \"0\" ] && echo 'PASSED' || echo 'FAILED' )"
          echo "NO-TOKENS mode (Test 9): $( [ \"$NO_TOKENS_FAILED\" = \"0\" ] && echo 'PASSED' || echo 'FAILED' )"
          echo ""

          TOTAL_FAILED=$((${WITH_TOKENS_FAILED:-0} + ${STRICT_MODE_FAILED:-0} + ${TRUSTED_ISSUER_FAILED:-0} + ${NO_TOKENS_FAILED:-0}))
          if [ $TOTAL_FAILED -gt 0 ]; then
            echo "Overall: SOME TESTS FAILED ($TOTAL_FAILED test(s))"
            exit 1
          fi
          echo "Overall: ALL TESTS PASSED"

      - name: Stop Server
        if: always()
        run: |
          if [ -f server/server.pid ]; then
            kill $(cat server/server.pid) 2>/dev/null || true
            kill -9 $(cat server/server.pid) 2>/dev/null || true
          fi
          if [ -f server/server_strict.pid ]; then
            kill $(cat server/server_strict.pid) 2>/dev/null || true
            kill -9 $(cat server/server_strict.pid) 2>/dev/null || true
          fi
          if [ -f server/server_trusted.pid ]; then
            kill $(cat server/server_trusted.pid) 2>/dev/null || true
            kill -9 $(cat server/server_trusted.pid) 2>/dev/null || true
          fi
          if [ -f server/server_no_tokens.pid ]; then
            kill $(cat server/server_no_tokens.pid) 2>/dev/null || true
            kill -9 $(cat server/server_no_tokens.pid) 2>/dev/null || true
          fi
          pkill -9 -f HytaleServerOriginal.jar 2>/dev/null || true

      - name: Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mock-client-test-logs
          path: |
            server/server.log
            server/server_strict.log
            server/server_trusted.log
            server/server_no_tokens.log
          retention-days: 7

  release:
    name: Deploy Release
    needs: [build-agent, test-server-boot, test-mock-client]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Agent Artifact
        uses: actions/download-artifact@v4
        with:
          name: dualauth-agent
          path: ./
          merge-multiple: true

      - name: Generate Changelog
        id: changelog
        run: |
          # Get commits for dualauth-agent since last tag or all if no tags
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            # No tags found, using all commits for the folder
            LOG=$(git log --oneline -- dualauth-agent/)
          else
            # Get changes since last tag that affected the folder
            LOG=$(git log ${LAST_TAG}..HEAD --oneline -- dualauth-agent/)
          fi
          
          # Clean up log and escape for GH output
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          if [ -z "$LOG" ]; then
            echo "No specific changes in dualauth-agent/ since last release." >> $GITHUB_OUTPUT
          else
            echo "$LOG" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create or Update GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.build-agent.outputs.version }}
          name: DualAuth Agent v${{ needs.build-agent.outputs.version }}
          body: |
            ## DualAuth Agent Release
            
            This release contains the latest `dualauth-agent.jar` built automatically by CI.
            
            ### Changes in dualauth-agent/:
            ${{ steps.changelog.outputs.CHANGELOG }}
          files: dualauth-agent.jar
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
