<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hytale Avatar Customizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 50%, #0d1b2a 100%);
      min-height: 100vh;
      color: #fff;
      display: flex;
      overflow: hidden;
    }

    /* Main Layout */
    .layout {
      display: flex;
      width: 100%;
      height: 100vh;
    }

    /* Left Panel - Customizer */
    .customizer-panel {
      width: 520px;
      min-width: 400px;
      background: linear-gradient(180deg, rgba(20, 35, 60, 0.95) 0%, rgba(15, 28, 48, 0.98) 100%);
      border: 1px solid rgba(100, 150, 200, 0.2);
      border-radius: 8px;
      margin: 20px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-header {
      background: linear-gradient(90deg, rgba(40, 70, 120, 0.6) 0%, rgba(30, 55, 95, 0.4) 100%);
      padding: 12px 20px;
      text-align: center;
      border-bottom: 1px solid rgba(100, 150, 200, 0.3);
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .panel-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Category Sidebar */
    .category-sidebar {
      width: 60px;
      background: rgba(10, 20, 35, 0.5);
      border-right: 1px solid rgba(100, 150, 200, 0.15);
      display: flex;
      flex-direction: column;
      padding: 8px 0;
    }

    .category-group {
      display: flex;
      flex-direction: column;
      border-bottom: 1px solid rgba(100, 150, 200, 0.1);
      padding: 4px 0;
    }

    .category-group:last-child {
      border-bottom: none;
    }

    .category-btn {
      width: 44px;
      height: 44px;
      margin: 2px auto;
      background: rgba(40, 60, 90, 0.3);
      border: 2px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      position: relative;
    }

    .category-btn:hover {
      background: rgba(60, 90, 130, 0.4);
      border-color: rgba(100, 150, 200, 0.3);
    }

    .category-btn.active {
      background: rgba(80, 130, 180, 0.4);
      border-color: rgba(200, 180, 100, 0.8);
      box-shadow: 0 0 10px rgba(200, 180, 100, 0.3);
    }

    .category-btn.group-header {
      background: rgba(200, 180, 100, 0.2);
    }

    .category-btn.group-header.active {
      background: rgba(200, 180, 100, 0.4);
    }

    .category-btn svg {
      width: 24px;
      height: 24px;
      fill: rgba(200, 200, 220, 0.8);
    }

    .category-btn.active svg {
      fill: rgba(255, 240, 200, 1);
    }

    .category-expand {
      position: absolute;
      right: -2px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 8px;
      color: rgba(200, 200, 220, 0.6);
    }

    /* Subcategory Sidebar */
    .subcategory-sidebar {
      width: 50px;
      background: rgba(15, 25, 40, 0.5);
      border-right: 1px solid rgba(100, 150, 200, 0.1);
      display: flex;
      flex-direction: column;
      padding: 8px 4px;
      overflow-y: auto;
    }

    .subcategory-btn {
      width: 40px;
      height: 40px;
      margin: 2px auto;
      background: rgba(40, 60, 90, 0.2);
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .subcategory-btn:hover {
      background: rgba(60, 90, 130, 0.3);
    }

    .subcategory-btn.active {
      background: rgba(80, 130, 180, 0.4);
      border-color: rgba(100, 180, 220, 0.6);
    }

    .subcategory-btn svg {
      width: 20px;
      height: 20px;
      fill: rgba(180, 180, 200, 0.7);
    }

    .subcategory-btn.active svg {
      fill: rgba(220, 240, 255, 1);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      overflow: hidden;
    }

    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      color: rgba(180, 200, 220, 0.8);
    }

    .breadcrumb-item {
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .breadcrumb-separator {
      color: rgba(100, 150, 200, 0.5);
    }

    .search-box {
      position: relative;
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      background: rgba(20, 35, 55, 0.6);
      border: 1px solid rgba(100, 150, 200, 0.2);
      border-radius: 4px;
      padding: 8px 12px 8px 32px;
      color: #fff;
      font-size: 13px;
    }

    .search-input:focus {
      outline: none;
      border-color: rgba(100, 180, 220, 0.5);
    }

    .search-input::placeholder {
      color: rgba(150, 170, 190, 0.5);
    }

    .search-icon {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 14px;
      height: 14px;
      fill: rgba(150, 170, 190, 0.5);
    }

    /* Style Grid */
    .style-grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      overflow-y: auto;
      padding-right: 8px;
      margin-bottom: 12px;
      align-content: start;
    }

    .style-grid::-webkit-scrollbar {
      width: 6px;
    }

    .style-grid::-webkit-scrollbar-track {
      background: rgba(20, 35, 55, 0.4);
      border-radius: 3px;
    }

    .style-grid::-webkit-scrollbar-thumb {
      background: rgba(80, 120, 160, 0.5);
      border-radius: 3px;
    }

    .style-item {
      aspect-ratio: 1;
      background: rgba(30, 50, 75, 0.5);
      border: 2px solid rgba(60, 90, 130, 0.3);
      border-radius: 6px;
      cursor: pointer;
      overflow: hidden;
      position: relative;
      transition: all 0.2s;
      min-height: 80px;
    }

    .style-item:hover {
      border-color: rgba(100, 150, 200, 0.5);
      transform: scale(1.03);
      z-index: 1;
    }

    .style-item.selected {
      border-color: rgba(200, 220, 150, 0.9);
      box-shadow: 0 0 12px rgba(200, 220, 150, 0.3);
    }

    .style-item.none-option {
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(40, 55, 75, 0.6);
    }

    .style-item.none-option svg {
      width: 32px;
      height: 32px;
      fill: rgba(150, 170, 190, 0.6);
    }

    .style-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      image-rendering: pixelated;
      background: linear-gradient(135deg, rgba(40, 60, 90, 0.6) 0%, rgba(30, 50, 80, 0.8) 100%);
      padding: 4px;
    }

    .thumbnail-placeholder {
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(50, 70, 100, 0.6) 0%, rgba(30, 50, 80, 0.8) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .thumbnail-placeholder::after {
      content: '';
      width: 32px;
      height: 32px;
      background: rgba(150, 170, 190, 0.3);
      border-radius: 4px;
    }

    .thumbnail-3d {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, rgba(30, 45, 70, 0.8) 0%, rgba(20, 35, 55, 0.9) 100%);
    }

    .thumbnail-3d img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .thumbnail-loading {
      color: rgba(150, 170, 190, 0.5);
      font-size: 16px;
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .style-item .item-icon {
      position: absolute;
      top: 4px;
      left: 4px;
      width: 16px;
      height: 16px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .style-item .item-icon svg {
      width: 12px;
      height: 12px;
      fill: rgba(255, 255, 255, 0.7);
    }

    .style-item .style-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.85));
      font-size: 9px;
      padding: 8px 4px 3px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }

    .style-check {
      position: absolute;
      bottom: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: rgba(100, 200, 150, 0.9);
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .style-item.selected .style-check {
      display: flex;
    }

    .style-check svg {
      width: 10px;
      height: 10px;
      fill: #fff;
    }

    /* Color Section */
    .color-section {
      border-top: 1px solid rgba(100, 150, 200, 0.15);
      padding-top: 12px;
    }

    .color-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: rgba(180, 200, 220, 0.7);
      margin-bottom: 8px;
    }

    .color-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .color-swatch {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid rgba(60, 90, 130, 0.4);
      transition: all 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      border-color: rgba(150, 180, 220, 0.6);
    }

    .color-swatch.selected {
      border-color: rgba(255, 220, 100, 0.9);
      box-shadow: 0 0 8px rgba(255, 220, 100, 0.4);
    }

    /* Variant Section */
    .variant-section {
      border-top: 1px solid rgba(100, 150, 200, 0.15);
      padding-top: 12px;
      margin-top: 12px;
    }

    .variant-toggle {
      display: flex;
      gap: 8px;
    }

    .variant-btn {
      flex: 1;
      padding: 8px 12px;
      background: rgba(30, 50, 75, 0.6);
      border: 2px solid rgba(60, 90, 130, 0.4);
      border-radius: 6px;
      color: rgba(180, 200, 220, 0.8);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .variant-btn:hover {
      background: rgba(40, 65, 95, 0.7);
      border-color: rgba(100, 150, 200, 0.5);
    }

    .variant-btn.selected {
      background: rgba(60, 100, 150, 0.5);
      border-color: rgba(200, 220, 150, 0.8);
      color: rgba(255, 255, 255, 0.95);
    }

    /* Right Panel - Preview */
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      padding-left: 0;
    }

    .preview-container {
      flex: 1;
      background: radial-gradient(ellipse at center bottom, rgba(40, 80, 60, 0.3) 0%, transparent 60%),
                  linear-gradient(180deg, rgba(20, 40, 60, 0.3) 0%, rgba(10, 25, 40, 0.5) 100%);
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
    }

    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 20, 35, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .loading-overlay.hidden {
      display: none;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(100, 150, 200, 0.2);
      border-top-color: rgba(100, 180, 220, 0.8);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 13px;
      color: rgba(180, 200, 220, 0.8);
    }

    /* Bottom Controls */
    .bottom-controls {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-top: 16px;
    }

    .control-btn {
      width: 40px;
      height: 40px;
      background: rgba(40, 60, 90, 0.5);
      border: 1px solid rgba(100, 150, 200, 0.3);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(60, 90, 130, 0.5);
    }

    .control-btn svg {
      width: 20px;
      height: 20px;
      fill: rgba(200, 200, 220, 0.8);
    }

    .action-btn {
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.2s;
    }

    .btn-discard {
      background: rgba(60, 80, 110, 0.6);
      border: 1px solid rgba(100, 150, 200, 0.3);
      color: rgba(200, 210, 220, 0.9);
    }

    .btn-discard:hover {
      background: rgba(80, 100, 130, 0.6);
    }

    .btn-save {
      background: linear-gradient(180deg, rgba(80, 140, 200, 0.8) 0%, rgba(60, 110, 170, 0.8) 100%);
      border: 1px solid rgba(120, 180, 220, 0.5);
      color: #fff;
    }

    .btn-save:hover {
      background: linear-gradient(180deg, rgba(100, 160, 220, 0.9) 0%, rgba(80, 130, 190, 0.9) 100%);
    }

    /* Animation Controls */
    .animation-select {
      background: rgba(40, 60, 90, 0.5);
      border: 1px solid rgba(100, 150, 200, 0.3);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      margin-right: auto;
    }

    .animation-select:focus {
      outline: none;
      border-color: rgba(100, 180, 220, 0.5);
    }
  </style>
</head>
<body>
  <div class="layout">
    <!-- Customizer Panel -->
    <div class="customizer-panel">
      <div class="panel-header">Customize Avatar</div>
      <div class="panel-content">
        <!-- Main Category Sidebar -->
        <div class="category-sidebar" id="category-sidebar">
          <!-- Categories will be populated by JS -->
        </div>

        <!-- Subcategory Sidebar -->
        <div class="subcategory-sidebar" id="subcategory-sidebar">
          <!-- Subcategories will be populated by JS -->
        </div>

        <!-- Main Content -->
        <div class="main-content">
          <div class="breadcrumb">
            <span class="breadcrumb-item" id="breadcrumb-category">HEAD</span>
            <span class="breadcrumb-separator">&#9656;</span>
            <span class="breadcrumb-item" id="breadcrumb-subcategory">EYES</span>
          </div>

          <div class="search-box">
            <svg class="search-icon" viewBox="0 0 24 24">
              <path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
            </svg>
            <input type="text" class="search-input" placeholder="Search" id="search-input">
          </div>

          <div class="style-grid" id="style-grid">
            <!-- Style items will be populated by JS -->
          </div>

          <div class="color-section" id="color-section">
            <div class="color-label">COLOR</div>
            <div class="color-grid" id="color-grid">
              <!-- Colors will be populated by JS -->
            </div>
          </div>

          <div class="variant-section" id="variant-section" style="display: none;">
            <div class="color-label">STYLE</div>
            <div class="variant-toggle" id="variant-toggle">
              <!-- Variant options will be populated by JS -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Preview Panel -->
    <div class="preview-panel">
      <div class="preview-container">
        <div id="canvas-container"></div>
        <div class="loading-overlay" id="loading-overlay">
          <div class="spinner"></div>
          <div class="loading-text" id="loading-text">Loading avatar...</div>
        </div>
      </div>

      <div class="bottom-controls">
        <select class="animation-select" id="animation-select">
          <option value="">No Animation</option>
          <option value="Default/Idle" selected>Idle</option>
          <option value="Default/Walk">Walk</option>
          <option value="Default/Run">Run</option>
          <option value="Default/Sprint">Sprint</option>
          <option value="Default/Jump">Jump</option>
          <option value="Default/Fall">Fall</option>
          <option value="Default/Crouch">Crouch</option>
          <option value="Emote/Wave">Wave</option>
          <option value="Emote/Dab_Left">Dab Left</option>
          <option value="Emote/Dab_Right">Dab Right</option>
          <option value="Taunt/Laugh">Laugh</option>
          <option value="Taunt/Chicken">Chicken</option>
          <option value="Poses/Sword">Sword Pose</option>
          <option value="Poses/Staff">Staff Pose</option>
          <option value="Swim/Swim">Swim</option>
          <option value="Glide/Glide">Glide</option>
        </select>

        <button class="control-btn" id="btn-rotate-left" title="Rotate Left">
          <svg viewBox="0 0 24 24"><path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z"/></svg>
        </button>
        <button class="control-btn" id="btn-rotate-right" title="Rotate Right">
          <svg viewBox="0 0 24 24"><path d="M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z"/></svg>
        </button>
        <button class="control-btn" id="btn-reset" title="Reset View">
          <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
        </button>
        <button class="control-btn" id="btn-randomize" title="Randomize">
          <svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>
        </button>

        <button class="action-btn btn-discard" id="btn-discard">Discard Changes</button>
        <button class="action-btn btn-save" id="btn-save">Save</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="/assets/avatar.js"></script>
  <script src="/assets/thumbnail-renderer.js"></script>
  <script>
    // Category definitions matching Hytale's structure with distinctive icons
    const CATEGORIES = {
      head: {
        name: 'Head',
        icon: `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12c0 1.85.5 3.58 1.37 5.07L2 22l4.93-1.37C8.42 21.5 10.15 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm0 18c-1.85 0-3.58-.5-5.07-1.37l-.36-.22-3.72 1.03 1.03-3.72-.22-.36C3.5 14.58 3 12.85 3 11c0-4.96 4.04-9 9-9s9 4.04 9 9-4.04 9-9 9z"/><circle cx="9" cy="10" r="1.5"/><circle cx="15" cy="10" r="1.5"/></svg>`,
        subcategories: {
          eyes: { name: 'Eyes', key: 'eyes', icon: `<svg viewBox="0 0 24 24"><path d="M12 4C7 4 2.73 7.11 1 11.5 2.73 15.89 7 19 12 19s9.27-3.11 11-7.5C21.27 7.11 17 4 12 4zm0 12.5c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>` },
          eyebrows: { name: 'Eyebrows', key: 'eyebrows', icon: `<svg viewBox="0 0 24 24"><path d="M3 9c0-1 1-3 5-3s4.5 1.5 4.5 1.5S13 6 17 6c4 0 5 2 5 3H3z"/><path d="M3 14c0-1 1-3 5-3s4.5 1.5 4.5 1.5S13 11 17 11c4 0 5 2 5 3H3z" opacity="0.5"/></svg>` },
          haircut: { name: 'Haircut', key: 'haircut', icon: `<svg viewBox="0 0 24 24"><path d="M12 2C9.24 2 7 4.24 7 7v4c0 2.76 2.24 5 5 5s5-2.24 5-5V7c0-2.76-2.24-5-5-5z"/><path d="M4 7c0-2 1-4 4-5 0 0-2 1-2 4v5c0 3.31 2.69 6 6 6s6-2.69 6-6V6c0-3-2-4-2-4 3 1 4 3 4 5v5c0 4.42-3.58 8-8 8s-8-3.58-8-8V7z"/></svg>` },
          face: { name: 'Face', key: 'face', icon: `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><circle cx="9" cy="10" r="1.5" fill="rgba(0,0,0,0.3)"/><circle cx="15" cy="10" r="1.5" fill="rgba(0,0,0,0.3)"/><path d="M8 15c0 0 2 2 4 2s4-2 4-2" stroke="rgba(0,0,0,0.3)" stroke-width="1.5" fill="none"/></svg>` },
          facialHair: { name: 'Facial Hair', key: 'facialHair', icon: `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.5.92 4.79 2.44 6.54C5.5 17.5 8.5 16 12 16s6.5 1.5 7.56 2.54A9.96 9.96 0 0022 12c0-5.52-4.48-10-10-10z"/><path d="M7 14c0 0 2 4 5 4s5-4 5-4c0 2-2.24 5-5 5s-5-3-5-5z"/></svg>` },
          mouth: { name: 'Mouth', key: 'mouth', icon: `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/><path d="M7 13c0 0 2 3 5 3s5-3 5-3-2 4-5 4-5-4-5-4z" fill="rgba(0,0,0,0.3)"/></svg>` },
          ears: { name: 'Ears', key: 'ears', icon: `<svg viewBox="0 0 24 24"><path d="M5 12c0-3.87 3.13-7 7-7s7 3.13 7 7"/><path d="M3 12c0 3 1.5 5 3 6l1-2c-1-.5-2-2-2-4 0-2.76 2.24-5 5-5h4c2.76 0 5 2.24 5 5 0 2-1 3.5-2 4l1 2c1.5-1 3-3 3-6 0-4.42-3.58-8-8-8H9c-4.42 0-8 3.58-8 8h2z"/></svg>` },
          headAccessory: { name: 'Head Accessory', key: 'headAccessory', icon: `<svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5M2 12l10 5 10-5" fill="none" stroke="currentColor" stroke-width="2"/></svg>` },
          faceAccessory: { name: 'Face Accessory', key: 'faceAccessory', icon: `<svg viewBox="0 0 24 24"><rect x="2" y="8" width="20" height="8" rx="2"/><circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/></svg>` },
          earAccessory: { name: 'Ear Accessory', key: 'earAccessory', icon: `<svg viewBox="0 0 24 24"><circle cx="6" cy="12" r="3"/><circle cx="18" cy="12" r="3"/><path d="M6 15v4M18 15v4" stroke="currentColor" stroke-width="2"/></svg>` }
        }
      },
      torso: {
        name: 'Torso',
        icon: `<svg viewBox="0 0 24 24"><path d="M12 2L8 6v2H6v12h12V8h-2V6l-4-4zm0 2.83L14 7v1h2v10H8V8h2V7l2-2.17z"/></svg>`,
        subcategories: {
          undertop: { name: 'Undertop', key: 'undertop', icon: `<svg viewBox="0 0 24 24"><path d="M12 4L8 8H6v12h12V8h-2l-4-4z" opacity="0.5"/><path d="M9 10h6v8H9z"/></svg>` },
          overtop: { name: 'Overtop', key: 'overtop', icon: `<svg viewBox="0 0 24 24"><path d="M12 2L6 8v12h12V8l-6-6zm0 2.83L16 9v9H8V9l4-4.17z"/></svg>` }
        }
      },
      arms: {
        name: 'Arms',
        icon: `<svg viewBox="0 0 24 24"><path d="M4 10c0-1 .5-2 1.5-2S7 9 7 10v7h3V8c0-1 .5-2 1.5-2s1.5 1 1.5 2v9h3v-7c0-1 .5-2 1.5-2s1.5 1 1.5 2v10H4V10z"/></svg>`,
        subcategories: {
          gloves: { name: 'Gloves', key: 'gloves', icon: `<svg viewBox="0 0 24 24"><path d="M14 2v6h2V2h-2zm-4 0v6h2V2h-2zm-4 6v10c0 2 2 4 4 4h4c2 0 4-2 4-4V8H6zm2 2h8v8c0 1-1 2-2 2h-4c-1 0-2-1-2-2v-8z"/></svg>` }
        }
      },
      legs: {
        name: 'Legs',
        icon: `<svg viewBox="0 0 24 24"><path d="M8 2h8v8H8z" opacity="0.3"/><path d="M8 10h3v12H8zm5 0h3v12h-3z"/></svg>`,
        subcategories: {
          pants: { name: 'Pants', key: 'pants', icon: `<svg viewBox="0 0 24 24"><path d="M6 2h12v6H6z" opacity="0.3"/><path d="M6 8h5v14H6zm7 0h5v14h-5z"/></svg>` },
          overpants: { name: 'Overpants', key: 'overpants', icon: `<svg viewBox="0 0 24 24"><path d="M5 2h14v4H5z"/><path d="M5 6h6v16H5zm8 0h6v16h-6z"/></svg>` },
          shoes: { name: 'Shoes', key: 'shoes', icon: `<svg viewBox="0 0 24 24"><path d="M4 16c0 2 2 4 4 4h8c2 0 4-2 4-4v-2H4v2z"/><path d="M6 12h4v2H6zm8 0h4v2h-4z"/></svg>` }
        }
      },
      general: {
        name: 'General',
        icon: `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4M2 12h4m12 0h4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/></svg>`,
        subcategories: {
          underwear: { name: 'Underwear', key: 'underwear', icon: `<svg viewBox="0 0 24 24"><path d="M6 6h12v4H6z" opacity="0.3"/><path d="M6 10h5v6l-3 4H6v-10zm7 0h5v10h-2l-3-4v-6z"/></svg>` },
          skinTone: { name: 'Skin Tone', key: 'skinTone', icon: `<svg viewBox="0 0 24 24"><circle cx="6" cy="6" r="3" fill="#f4c39a"/><circle cx="12" cy="6" r="3" fill="#ba7f5b"/><circle cx="18" cy="6" r="3" fill="#6f3b2c"/><circle cx="6" cy="12" r="3" fill="#e0ae72"/><circle cx="12" cy="12" r="3" fill="#945d44"/><circle cx="18" cy="12" r="3" fill="#4f2a24"/></svg>` },
          bodyCharacteristic: { name: 'Body Type', key: 'bodyCharacteristic', icon: `<svg viewBox="0 0 24 24"><circle cx="12" cy="5" r="3"/><path d="M8 10h8v3H8z"/><path d="M9 13h2v9H9zm4 0h2v9h-2z"/></svg>` }
        }
      },
      capes: {
        name: 'Capes',
        icon: `<svg viewBox="0 0 24 24"><path d="M12 2c-2 0-4 1-4 1v18s2 1 4 1 4-1 4-1V3s-2-1-4-1z"/><path d="M8 3C6 4 4 6 4 10v10c2-2 4-3 4-3V3zm8 0v14s2 1 4 3V10c0-4-2-6-4-7z" opacity="0.5"/></svg>`,
        subcategories: {
          cape: { name: 'Capes', key: 'cape', icon: `<svg viewBox="0 0 24 24"><path d="M12 2c-3 0-6 1-6 1v18s3 1 6 1 6-1 6-1V3s-3-1-6-1z"/></svg>` }
        }
      }
    };

    // Current state
    let currentCategory = 'head';
    let currentSubcategory = 'eyes';
    let currentSkin = {};
    let currentColors = {};
    let currentVariants = {};    // category -> variant id (e.g., 'cape' -> 'Neck_Piece')
    let originalSkin = {};
    let originalColors = {};
    let originalVariants = {};
    let cosmeticItems = {};      // category -> array of {id, name, thumbnail, colors, variants}
    let colorHexMap = {};        // colorId -> hex color
    let gradientSetsInfo = [];   // gradient sets with their color lists
    let viewer = null;
    let thumbnailRenderer = null; // 3D thumbnail renderer
    let refreshDebounce = null;

    // Get UUID from URL or generate test one
    function getUUID() {
      const pathParts = window.location.pathname.split('/');
      const idx = pathParts.indexOf('customizer');
      if (idx >= 0 && pathParts[idx + 1]) {
        return pathParts[idx + 1];
      }
      return 'test-' + Math.random().toString(36).substr(2, 9);
    }

    const UUID = getUUID();

    // Initialize
    async function init() {
      setupCategories();
      setupControls();
      await loadCosmeticItems();

      // Initialize 3D thumbnail renderer
      thumbnailRenderer = new ThumbnailRenderer();
      await thumbnailRenderer.init();

      await initViewer();
      selectCategory('head');
      selectSubcategory('eyes');
    }

    function setupCategories() {
      const sidebar = document.getElementById('category-sidebar');
      sidebar.innerHTML = '';

      for (const [key, category] of Object.entries(CATEGORIES)) {
        const group = document.createElement('div');
        group.className = 'category-group';

        const btn = document.createElement('button');
        btn.className = 'category-btn group-header';
        btn.dataset.category = key;
        btn.innerHTML = category.icon;
        btn.onclick = () => selectCategory(key);

        // Add expand indicator if has subcategories
        if (Object.keys(category.subcategories).length > 1) {
          const expand = document.createElement('span');
          expand.className = 'category-expand';
          expand.textContent = 'â–¶';
          btn.appendChild(expand);
        }

        group.appendChild(btn);
        sidebar.appendChild(group);
      }
    }

    function selectCategory(categoryKey) {
      currentCategory = categoryKey;
      const category = CATEGORIES[categoryKey];

      // Update active state
      document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.category === categoryKey);
      });

      // Update subcategory sidebar
      const subSidebar = document.getElementById('subcategory-sidebar');
      subSidebar.innerHTML = '';

      for (const [subKey, sub] of Object.entries(category.subcategories)) {
        const btn = document.createElement('button');
        btn.className = 'subcategory-btn';
        btn.dataset.subcategory = subKey;
        btn.innerHTML = sub.icon;
        btn.title = sub.name;
        btn.onclick = () => selectSubcategory(subKey);
        subSidebar.appendChild(btn);
      }

      // Select first subcategory
      const firstSub = Object.keys(category.subcategories)[0];
      selectSubcategory(firstSub);
    }

    function selectSubcategory(subKey) {
      currentSubcategory = subKey;
      const category = CATEGORIES[currentCategory];
      const subcategory = category.subcategories[subKey];

      // Update active state
      document.querySelectorAll('.subcategory-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.subcategory === subKey);
      });

      // Update breadcrumb
      document.getElementById('breadcrumb-category').textContent = category.name.toUpperCase();
      document.getElementById('breadcrumb-subcategory').textContent = subcategory.name.toUpperCase();

      // Load styles for this subcategory
      loadStylesForCategory(subcategory.key);
      loadColorsForCategory(subcategory.key);
    }

    async function loadCosmeticItems() {
      try {
        const response = await fetch('/cosmetics/list');
        if (response.ok) {
          const data = await response.json();
          // New API format: { items: {...}, colorHexMap: {...}, gradientSets: [...] }
          cosmeticItems = data.items || {};
          colorHexMap = data.colorHexMap || {};
          gradientSetsInfo = data.gradientSets || [];
          console.log('Loaded cosmetics:', Object.keys(cosmeticItems));
          console.log('Color map entries:', Object.keys(colorHexMap).length);
        }
      } catch (e) {
        console.log('Could not load cosmetics list:', e);
        cosmeticItems = {};
        colorHexMap = {};
        gradientSetsInfo = [];
      }
    }

    // Handle thumbnail loading errors - try alternative paths
    function handleThumbnailError(img, originalPath) {
      const pathsToTry = [
        '/asset/Common/' + originalPath,
        '/asset/Cosmetics/' + originalPath,
        '/asset/' + originalPath.replace('Characters/', 'Common/Characters/'),
        '/asset/' + originalPath.replace('Cosmetics/', 'Common/Cosmetics/')
      ];

      const currentSrc = img.src;
      const triedPaths = img.dataset.triedPaths ? JSON.parse(img.dataset.triedPaths) : [currentSrc];

      for (const path of pathsToTry) {
        const fullPath = window.location.origin + path;
        if (!triedPaths.includes(fullPath)) {
          triedPaths.push(fullPath);
          img.dataset.triedPaths = JSON.stringify(triedPaths);
          img.src = path;
          return;
        }
      }

      // All paths failed - show placeholder
      img.style.display = 'none';
      const placeholder = img.parentElement.querySelector('.thumbnail-placeholder');
      if (placeholder) placeholder.style.display = 'flex';
    }

    function loadStylesForCategory(categoryKey) {
      const grid = document.getElementById('style-grid');
      grid.innerHTML = '';

      const selectedId = currentSkin[categoryKey];
      const selectedColor = currentColors[categoryKey];
      const skinTone = currentSkin.skinTone || '01';

      // Add "None" option
      const noneItem = document.createElement('div');
      noneItem.className = 'style-item none-option';
      if (!selectedId) noneItem.classList.add('selected');
      noneItem.innerHTML = `
        <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        <div class="style-check"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></div>
      `;
      noneItem.onclick = () => selectStyle(categoryKey, null);
      grid.appendChild(noneItem);

      // Get items for this category (array of objects with id, name, thumbnail, colors)
      const items = cosmeticItems[categoryKey] || [];

      for (const itemData of items) {
        const item = document.createElement('div');
        item.className = 'style-item';
        item.dataset.id = itemData.id;
        item.dataset.name = itemData.name || itemData.id;
        item.dataset.category = categoryKey;

        if (selectedId === itemData.id) {
          item.classList.add('selected');
        }

        // Display name (clean up the ID for display)
        const displayName = itemData.id.replace(/_/g, ' ');

        // Create placeholder for 3D thumbnail (will be rendered async)
        const thumbnailHtml = `
          <div class="thumbnail-3d" data-category="${categoryKey}" data-item-id="${itemData.id}">
            <div class="thumbnail-loading">...</div>
          </div>
        `;

        item.innerHTML = `
          ${thumbnailHtml}
          <div class="style-label">${displayName}</div>
          <div class="style-check"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></div>
        `;

        // Store item colors for the color picker (each item has its own colors)
        item.dataset.colors = JSON.stringify(itemData.colors || []);

        item.onclick = () => selectStyle(categoryKey, itemData.id, itemData.colors);
        grid.appendChild(item);

        // Queue 3D thumbnail rendering (async, don't await)
        // Thumbnails ALWAYS show the item's default (first) color - never affected by selection
        if (thumbnailRenderer) {
          const thumbContainer = item.querySelector('.thumbnail-3d');
          const itemColors = itemData.colors || [];
          // Always use the item's first color for thumbnails - selection doesn't change this
          const colorForThumb = itemColors.length > 0 ? itemColors[0] : null;
          render3DThumbnail(thumbContainer, categoryKey, itemData.id, colorForThumb, skinTone);
        }
      }

      // If no items, show placeholder
      if (items.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.style.cssText = 'grid-column: 1/-1; text-align: center; padding: 40px 20px; color: rgba(150,170,190,0.5); font-size: 13px;';
        placeholder.textContent = 'No items available';
        grid.appendChild(placeholder);
      }
    }

    // Render a 3D thumbnail asynchronously
    async function render3DThumbnail(container, category, itemId, colorId, skinTone) {
      try {
        const dataUrl = await thumbnailRenderer.renderThumbnail(category, itemId, colorId, skinTone);
        if (dataUrl) {
          container.innerHTML = `<img src="${dataUrl}" alt="${itemId}">`;
        } else {
          container.innerHTML = '<div class="thumbnail-placeholder">?</div>';
        }
      } catch (err) {
        console.warn('Thumbnail render failed:', category, itemId, err);
        container.innerHTML = '<div class="thumbnail-placeholder">!</div>';
      }
    }

    function loadColorsForCategory(categoryKey) {
      const colorSection = document.getElementById('color-section');
      const colorGrid = document.getElementById('color-grid');

      // Find the item's available colors
      const items = cosmeticItems[categoryKey] || [];
      const selectedId = currentSkin[categoryKey];
      const selectedItem = items.find(i => i.id === selectedId);

      colorGrid.innerHTML = '';

      // If item has specific colors from gradient set or textures
      if (selectedItem && selectedItem.colors && selectedItem.colors.length > 0) {
        colorSection.style.display = 'block';

        const selectedColor = currentColors[categoryKey];

        // Sort colors for consistent ordering
        // Numbers first (skin tones), then alphabetically
        const sortedColors = [...selectedItem.colors].sort((a, b) => {
          const aIsNum = /^\d+$/.test(a);
          const bIsNum = /^\d+$/.test(b);
          if (aIsNum && bIsNum) return parseInt(a) - parseInt(b);
          if (aIsNum) return -1;
          if (bIsNum) return 1;
          return a.localeCompare(b);
        });

        for (const colorId of sortedColors) {
          const swatch = document.createElement('div');
          swatch.className = 'color-swatch';
          swatch.title = colorId.replace(/_/g, ' ');

          // Get color from our mapping functions
          const colorHex = getColorForId(colorId, categoryKey);
          swatch.style.backgroundColor = colorHex;

          if (colorId === selectedColor) {
            swatch.classList.add('selected');
          }

          swatch.onclick = () => selectColor(categoryKey, colorId);
          colorGrid.appendChild(swatch);
        }
      } else {
        // No colors available for this category/item
        colorSection.style.display = 'none';
      }

      // Also load variants for this category
      loadVariantsForCategory(categoryKey);
    }

    function loadVariantsForCategory(categoryKey) {
      const variantSection = document.getElementById('variant-section');
      const variantToggle = document.getElementById('variant-toggle');

      // Find the item's available variants
      const items = cosmeticItems[categoryKey] || [];
      const selectedId = currentSkin[categoryKey];
      const selectedItem = items.find(i => i.id === selectedId);

      variantToggle.innerHTML = '';

      // If item has variants (like capes with Neck_Piece/NoNeck)
      if (selectedItem && selectedItem.variants && selectedItem.variants.length > 1) {
        variantSection.style.display = 'block';

        const selectedVariant = currentVariants[categoryKey] || selectedItem.variants[0].id;

        for (const variant of selectedItem.variants) {
          const btn = document.createElement('button');
          btn.className = 'variant-btn';
          if (variant.id === selectedVariant) {
            btn.classList.add('selected');
          }

          // Clean up variant name for display
          let displayName = variant.id;
          if (variant.id === 'Neck_Piece') displayName = 'With Collar';
          else if (variant.id === 'NoNeck') displayName = 'No Collar';
          else displayName = variant.id.replace(/_/g, ' ');

          btn.textContent = displayName;
          btn.onclick = () => selectVariant(categoryKey, variant.id);
          variantToggle.appendChild(btn);
        }
      } else {
        // No variants available for this item
        variantSection.style.display = 'none';
      }
    }

    function selectVariant(categoryKey, variantId) {
      currentVariants[categoryKey] = variantId;

      // Update UI
      loadVariantsForCategory(categoryKey);

      // Refresh preview
      scheduleRefresh();
    }

    // Map color IDs to hex values using the colorHexMap from the API
    function getColorForId(colorId, categoryKey) {
      // First check the API-provided color map (from gradient sets)
      if (colorHexMap[colorId]) {
        return colorHexMap[colorId];
      }

      // Fallback to static color mappings for common colors
      const staticColorMap = {
        // Hair colors
        'PitchBlack': '#06070a', 'Black': '#121325', 'BrownDarker': '#1f110c',
        'BrownDark': '#2e0b06', 'BrownSemiDark': '#401a13', 'Brown': '#5d2014',
        'BrownSemiLight': '#834220', 'BrownLight': '#a06536', 'Blond': '#dca65f',
        'BlondPlatinum': '#fbd579', 'BlondSand': '#d7b698', 'BlondCaramel': '#a98747',
        'Copper': '#e66d33', 'Red': '#b51717', 'RedDark': '#5e0606',
        'Pink': '#a71849', 'PinkBerry': '#ca4a5f', 'Bubblegum': '#ea79a3',
        'Purple': '#582e77', 'Lavender': '#785da7', 'BlueDark': '#181d55',
        'Blue': '#2164a8', 'BlueLight': '#aed3e2', 'Turquoise': '#258c95',
        'Green': '#279a67', 'White': '#e4e4e9', 'GreyAsh': '#ada192',
        'Grey': '#838393', 'GreyPurple': '#42485b', 'Blue_Anthracite': '#333146',
        // Skin tones
        '01': '#f4c39a', '02': '#f5c490', '03': '#e0ae72', '04': '#ba7f5b', '05': '#945d44',
        '06': '#6f3b2c', '07': '#4f2a24', '08': '#dcc7a8', '09': '#f5bc83', '10': '#d98c5b',
        '11': '#ab7a4c', '12': '#7d432b', '13': '#513425', '14': '#31221f', '15': '#d5a082',
        '16': '#63492f', '17': '#5e3a2f', '18': '#4d272b', '19': '#8aacfb', '20': '#a78af1',
        '21': '#fc8572', '22': '#9bc55d',
        // Eye colors
        'Blue_Eye': '#5391c1', 'Turquoise_Eye': '#31a1af', 'Black_Eye': '#191111',
        'Grey_Eye': '#8a9295', 'Hazelnut': '#7d4e33', 'Honey': '#a97f37',
        'Brown_Eye': '#5f2f2f', 'Orange_Eye': '#d78d4c', 'GreenDark': '#11552c',
        'Lime': '#b8f347', 'OceanBlue': '#2b2a77', 'IceBlue': '#72f2f4',
        // Generic fallbacks
        'Default': '#888888'
      };

      if (staticColorMap[colorId]) {
        return staticColorMap[colorId];
      }

      // Last resort: generate a deterministic color from the colorId string
      // This is better than random because it will be consistent
      let hash = 0;
      for (let i = 0; i < colorId.length; i++) {
        hash = colorId.charCodeAt(i) + ((hash << 5) - hash);
      }
      const color = (hash & 0x00FFFFFF).toString(16).padStart(6, '0');
      return '#' + color;
    }

    function selectStyle(categoryKey, itemId, availableColors = null) {
      if (itemId === null) {
        delete currentSkin[categoryKey];
        delete currentColors[categoryKey];
        delete currentVariants[categoryKey];
      } else {
        currentSkin[categoryKey] = itemId;

        // Get item data for color/variant validation
        const items = cosmeticItems[categoryKey] || [];
        const selectedItem = items.find(i => i.id === itemId);
        const itemColors = selectedItem?.colors || availableColors || [];
        const itemVariants = selectedItem?.variants || [];

        // Reset color if current color is not valid for this item
        const currentColor = currentColors[categoryKey];
        if (itemColors.length > 0) {
          if (!currentColor || !itemColors.includes(currentColor)) {
            // Current color not valid for new item - select first available
            currentColors[categoryKey] = itemColors[0];
          }
        } else {
          // No colors available - clear color selection
          delete currentColors[categoryKey];
        }

        // Reset variant if current variant is not valid for this item
        const currentVariant = currentVariants[categoryKey];
        if (itemVariants.length > 0) {
          const variantIds = itemVariants.map(v => v.id);
          if (!currentVariant || !variantIds.includes(currentVariant)) {
            // Current variant not valid for new item - select first available
            currentVariants[categoryKey] = itemVariants[0].id;
          }
        } else {
          // No variants available - clear variant selection
          delete currentVariants[categoryKey];
        }
      }

      // Update selection state without re-rendering thumbnails
      updateStyleSelection(categoryKey, itemId);
      loadColorsForCategory(categoryKey);

      // Refresh avatar preview with debounce
      scheduleRefresh();
    }

    // Update just the selection visual state without rebuilding the grid
    function updateStyleSelection(categoryKey, selectedId) {
      const grid = document.getElementById('style-grid');
      const items = grid.querySelectorAll('.style-item');

      items.forEach(item => {
        const itemId = item.dataset.id;
        if (itemId === selectedId) {
          item.classList.add('selected');
        } else {
          item.classList.remove('selected');
        }
      });

      // Handle "None" option
      const noneOption = grid.querySelector('.none-option');
      if (noneOption) {
        if (!selectedId) {
          noneOption.classList.add('selected');
        } else {
          noneOption.classList.remove('selected');
        }
      }
    }

    function selectColor(categoryKey, colorId) {
      currentColors[categoryKey] = colorId;

      // Update UI
      loadColorsForCategory(categoryKey);

      // Refresh preview
      scheduleRefresh();
    }

    function scheduleRefresh() {
      // Debounce refresh to avoid too many reloads
      if (refreshDebounce) clearTimeout(refreshDebounce);
      refreshDebounce = setTimeout(() => refreshPreview(), 100);
    }

    async function initViewer() {
      const container = document.getElementById('canvas-container');

      viewer = new HytaleAvatarViewer(container, {
        autoRotate: true,
        showGrid: true,
        onLoadProgress: (text) => {
          document.getElementById('loading-text').textContent = text;
        },
        onLoadComplete: () => {
          document.getElementById('loading-overlay').classList.add('hidden');
        },
        onError: (err) => {
          document.getElementById('loading-text').textContent = 'Error: ' + err.message;
          console.error('Viewer error:', err);
        }
      });

      viewer.init();

      try {
        await viewer.loadAvatar(UUID);
        // Store original skin for discard
        if (viewer.modelData && viewer.modelData.raw) {
          originalSkin = { ...viewer.modelData.raw };
          currentSkin = { ...viewer.modelData.raw };
          // Parse colors and variants from raw data (format: "ItemId.ColorId.VariantId")
          for (const [key, value] of Object.entries(currentSkin)) {
            if (typeof value === 'string' && value.includes('.')) {
              const parts = value.split('.');
              currentSkin[key] = parts[0];
              // Handle empty color (e.g., "ItemId..VariantId")
              if (parts[1]) {
                currentColors[key] = parts[1];
              }
              if (parts[2]) {
                currentVariants[key] = parts[2];
              }
            }
          }
          originalColors = { ...currentColors };
          originalVariants = { ...currentVariants };
        }
      } catch (e) {
        console.error('Failed to load avatar:', e);
        // Still allow customization even if initial load fails
        document.getElementById('loading-overlay').classList.add('hidden');
      }
    }

    async function refreshPreview() {
      console.log('Refreshing preview with skin:', currentSkin, 'colors:', currentColors, 'variants:', currentVariants);

      // Show loading
      document.getElementById('loading-overlay').classList.remove('hidden');
      document.getElementById('loading-text').textContent = 'Updating preview...';

      try {
        // Build skin data string for preview
        // Format: ItemId.ColorId.VariantId (variant is optional)
        const previewSkin = {};
        for (const [key, itemId] of Object.entries(currentSkin)) {
          const colorId = currentColors[key];
          const variantId = currentVariants[key];

          if (colorId && variantId) {
            previewSkin[key] = `${itemId}.${colorId}.${variantId}`;
          } else if (colorId) {
            previewSkin[key] = `${itemId}.${colorId}`;
          } else if (variantId) {
            previewSkin[key] = `${itemId}..${variantId}`; // Empty color with variant
          } else {
            previewSkin[key] = itemId;
          }
        }

        // Post updated skin to server and get resolved model
        const response = await fetch(`/avatar/${UUID}/preview`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(previewSkin)
        });

        if (response.ok) {
          const data = await response.json();

          // Clear and rebuild the character
          while (viewer.character.children.length > 0) {
            viewer.character.remove(viewer.character.children[0]);
          }
          viewer.originalTransforms.clear();
          viewer.hiddenBodyParts.clear();
          viewer.polygonOffsetParts.clear();
          viewer.textureCache.clear();

          viewer.modelData = data;
          viewer._determineHiddenParts(data);
          await viewer._buildCharacter(data);
        } else {
          console.error('Preview update failed:', await response.text());
        }
      } catch (e) {
        console.error('Preview error:', e);
      }

      document.getElementById('loading-overlay').classList.add('hidden');
    }

    function setupControls() {
      document.getElementById('animation-select').addEventListener('change', (e) => {
        if (viewer) viewer.setAnimation(e.target.value);
      });

      document.getElementById('btn-rotate-left').onclick = () => {
        if (viewer) viewer.rotate(-0.3);
      };

      document.getElementById('btn-rotate-right').onclick = () => {
        if (viewer) viewer.rotate(0.3);
      };

      document.getElementById('btn-reset').onclick = () => {
        if (viewer) viewer.resetView();
      };

      document.getElementById('btn-randomize').onclick = () => {
        randomizeSkin();
      };

      document.getElementById('btn-discard').onclick = () => {
        currentSkin = { ...originalSkin };
        currentColors = { ...originalColors };
        currentVariants = { ...originalVariants };
        const category = CATEGORIES[currentCategory];
        const subcategory = category.subcategories[currentSubcategory];
        loadStylesForCategory(subcategory.key);
        loadColorsForCategory(subcategory.key);
        loadVariantsForCategory(subcategory.key);
        scheduleRefresh();
      };

      document.getElementById('btn-save').onclick = async () => {
        await saveSkin();
      };

      document.getElementById('search-input').addEventListener('input', (e) => {
        filterStyles(e.target.value);
      });
    }

    function filterStyles(query) {
      const items = document.querySelectorAll('.style-item:not(.none-option)');
      const lowerQuery = query.toLowerCase();

      items.forEach(item => {
        const name = (item.dataset.name || item.dataset.id || '').toLowerCase();
        const id = (item.dataset.id || '').toLowerCase();
        const matches = name.includes(lowerQuery) || id.includes(lowerQuery);
        item.style.display = matches ? '' : 'none';
      });
    }

    function randomizeSkin() {
      for (const [catKey, category] of Object.entries(CATEGORIES)) {
        for (const [subKey, sub] of Object.entries(category.subcategories)) {
          const items = cosmeticItems[sub.key] || [];
          if (items.length > 0 && Math.random() > 0.3) {
            const randomItem = items[Math.floor(Math.random() * items.length)];
            currentSkin[sub.key] = randomItem.id;
            // Pick random color if available
            if (randomItem.colors && randomItem.colors.length > 0) {
              currentColors[sub.key] = randomItem.colors[Math.floor(Math.random() * randomItem.colors.length)];
            }
            // Pick random variant if available
            if (randomItem.variants && randomItem.variants.length > 0) {
              currentVariants[sub.key] = randomItem.variants[Math.floor(Math.random() * randomItem.variants.length)].id;
            } else {
              delete currentVariants[sub.key];
            }
          } else if (Math.random() > 0.7) {
            delete currentSkin[sub.key];
            delete currentColors[sub.key];
            delete currentVariants[sub.key];
          }
        }
      }

      const category = CATEGORIES[currentCategory];
      const subcategory = category.subcategories[currentSubcategory];
      loadStylesForCategory(subcategory.key);
      loadColorsForCategory(subcategory.key);
      loadVariantsForCategory(subcategory.key);
      scheduleRefresh();
    }

    async function saveSkin() {
      // Build final skin data with colors and variants
      const saveSkin = {};
      for (const [key, itemId] of Object.entries(currentSkin)) {
        const colorId = currentColors[key];
        const variantId = currentVariants[key];

        if (colorId && variantId) {
          saveSkin[key] = `${itemId}.${colorId}.${variantId}`;
        } else if (colorId) {
          saveSkin[key] = `${itemId}.${colorId}`;
        } else if (variantId) {
          saveSkin[key] = `${itemId}..${variantId}`;
        } else {
          saveSkin[key] = itemId;
        }
      }

      try {
        const response = await fetch(`/account-data/skin/${UUID}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(saveSkin)
        });

        if (response.ok) {
          originalSkin = { ...currentSkin };
          originalColors = { ...currentColors };
          originalVariants = { ...currentVariants };
          alert('Skin saved successfully!');
        } else {
          alert('Failed to save skin: ' + await response.text());
        }
      } catch (e) {
        console.error('Save error:', e);
        alert('Failed to save skin: ' + e.message);
      }
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
